/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g
 *     -                            On : 2013-06-07 19:41:01
 *     -           for the tree parser : CompilerTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

#include <string>
#include <vector>
#include <cstdlib>
#include <cstddef>
#include <algorithm>
#include <cinamo/String.h>
#include <donut/source/Source.h>
#include <donut/source/Closure.h>
#include "../ParseUtil.h"

using namespace cinamo;
using namespace donut;
using std::string;
using std::nullptr_t;
using donut::unescapeString;
using cinamo::parseAs;

typedef pANTLR3_COMMON_TOKEN Token;

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "Compiler.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pCompiler_##scope##_SCOPE
#define SCOPE_STACK(scope)  pCompiler_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pCompiler_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pCompiler_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO
#undef		SEEK
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger



#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   CompilerTokenNames[99+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ADD",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "APPLY",
        (pANTLR3_UINT8) "ARGS",
        (pANTLR3_UINT8) "ARRAY",
        (pANTLR3_UINT8) "ASSIGN",
        (pANTLR3_UINT8) "ASSIGN_OP",
        (pANTLR3_UINT8) "BIT_AND",
        (pANTLR3_UINT8) "BIT_OR",
        (pANTLR3_UINT8) "CEQ",
        (pANTLR3_UINT8) "CGE",
        (pANTLR3_UINT8) "CGT",
        (pANTLR3_UINT8) "CLE",
        (pANTLR3_UINT8) "CLOS",
        (pANTLR3_UINT8) "CLT",
        (pANTLR3_UINT8) "CNE",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "COND",
        (pANTLR3_UINT8) "CONT",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DIV",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "EXPONENT",
        (pANTLR3_UINT8) "FALSE_LITERAL",
        (pANTLR3_UINT8) "FLOAT_LITERAL",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "FUNC",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "HEX_LITERAL",
        (pANTLR3_UINT8) "IDENT",
        (pANTLR3_UINT8) "INTERRUPT",
        (pANTLR3_UINT8) "INT_LITERAL",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "MOD",
        (pANTLR3_UINT8) "MUL",
        (pANTLR3_UINT8) "NONZERO_DIGIT",
        (pANTLR3_UINT8) "NOT",
        (pANTLR3_UINT8) "NULL_LITERAL",
        (pANTLR3_UINT8) "OBJECT",
        (pANTLR3_UINT8) "OCT_DIGIT",
        (pANTLR3_UINT8) "OCT_LITERAL",
        (pANTLR3_UINT8) "OR",
        (pANTLR3_UINT8) "PAIR",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "POST_OP",
        (pANTLR3_UINT8) "PRE_OP",
        (pANTLR3_UINT8) "RETURN",
        (pANTLR3_UINT8) "SCOPE",
        (pANTLR3_UINT8) "SELF",
        (pANTLR3_UINT8) "STRING_DOUBLE",
        (pANTLR3_UINT8) "STRING_DOUBLE_ELEMENT",
        (pANTLR3_UINT8) "STRING_SINGLE",
        (pANTLR3_UINT8) "STRING_SINGLE_ELEMENT",
        (pANTLR3_UINT8) "SUB",
        (pANTLR3_UINT8) "TRUE_LITERAL",
        (pANTLR3_UINT8) "VAR",
        (pANTLR3_UINT8) "VARS",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'%='",
        (pANTLR3_UINT8) "'&&'",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'*='",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'++'",
        (pANTLR3_UINT8) "'+='",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'--'",
        (pANTLR3_UINT8) "'-='",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "'/='",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'<='",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'=>'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'for'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'var'",
        (pANTLR3_UINT8) "'while'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'|'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'}'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 Handler<donut::Source>
	prog    (pCompiler ctx);
static 
 Compiler_closure_return
	closure    (pCompiler ctx, donut::Source* code);
static 
 std::vector<std::string>
	vars    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	defvar    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	block    (pCompiler ctx, donut::Source* code);
static 
 std::string
	operation    (pCompiler ctx);
static 
 std::string
	unary_operation    (pCompiler ctx);
static 
 std::vector<donut::Instruction>
	expr    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	preop    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	postop    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	assignop    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	assign    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	accessor    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	apply    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	cond    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	loop    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	literal    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	return_    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	interrupt    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	object    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	object_pair    (pCompiler ctx, donut::Source* code);
static 
 std::vector<donut::Instruction>
	array    (pCompiler ctx, donut::Source* code);
static 
 Compiler_arglist_return
	arglist    (pCompiler ctx, donut::Source* code);
static void	CompilerFree(pCompiler ctx);
static void     CompilerReset (pCompiler ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new Compiler parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCompiler
CompilerNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return CompilerNewSSD(instream, NULL);
}

/** \brief Create a new Compiler parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pCompiler
CompilerNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pCompiler ctx;	    /* Context structure we will build and return   */

    ctx	= (pCompiler) ANTLR3_CALLOC(1, sizeof(Compiler));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in Compiler.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Install the implementation of our Compiler interface
     */
    ctx->prog	= prog;
    ctx->closure	= closure;
    ctx->vars	= vars;
    ctx->defvar	= defvar;
    ctx->block	= block;
    ctx->operation	= operation;
    ctx->unary_operation	= unary_operation;
    ctx->expr	= expr;
    ctx->preop	= preop;
    ctx->postop	= postop;
    ctx->assignop	= assignop;
    ctx->assign	= assign;
    ctx->accessor	= accessor;
    ctx->apply	= apply;
    ctx->cond	= cond;
    ctx->loop	= loop;
    ctx->literal	= literal;
    ctx->return_	= return_;
    ctx->interrupt	= interrupt;
    ctx->object	= object;
    ctx->object_pair	= object_pair;
    ctx->array	= array;
    ctx->arglist	= arglist;
    ctx->free			= CompilerFree;
    ctx->reset			= CompilerReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = CompilerTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
CompilerReset (pCompiler ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 CompilerFree(pCompiler ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);

    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
tree parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return CompilerTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_closure_in_prog64  */
static	ANTLR3_BITWORD FOLLOW_closure_in_prog64_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_closure_in_prog64	= { FOLLOW_closure_in_prog64_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOS_in_closure86  */
static	ANTLR3_BITWORD FOLLOW_CLOS_in_closure86_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOS_in_closure86	= { FOLLOW_CLOS_in_closure86_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_vars_in_closure88  */
static	ANTLR3_BITWORD FOLLOW_vars_in_closure88_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_vars_in_closure88	= { FOLLOW_vars_in_closure88_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_closure91  */
static	ANTLR3_BITWORD FOLLOW_block_in_closure91_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_closure91	= { FOLLOW_block_in_closure91_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARS_in_vars116  */
static	ANTLR3_BITWORD FOLLOW_VARS_in_vars116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARS_in_vars116	= { FOLLOW_VARS_in_vars116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_vars119  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_vars119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_vars119	= { FOLLOW_IDENT_in_vars119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VAR_in_defvar139  */
static	ANTLR3_BITWORD FOLLOW_VAR_in_defvar139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VAR_in_defvar139	= { FOLLOW_VAR_in_defvar139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_defvar141  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_defvar141_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDA736FFF78) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_defvar141	= { FOLLOW_IDENT_in_defvar141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_defvar145  */
static	ANTLR3_BITWORD FOLLOW_expr_in_defvar145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_defvar145	= { FOLLOW_expr_in_defvar145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONT_in_block173  */
static	ANTLR3_BITWORD FOLLOW_CONT_in_block173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONT_in_block173	= { FOLLOW_CONT_in_block173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_block178  */
static	ANTLR3_BITWORD FOLLOW_expr_in_block178_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDA736FFF78) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_block178	= { FOLLOW_expr_in_block178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ADD_in_operation200  */
static	ANTLR3_BITWORD FOLLOW_ADD_in_operation200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ADD_in_operation200	= { FOLLOW_ADD_in_operation200_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SUB_in_operation207  */
static	ANTLR3_BITWORD FOLLOW_SUB_in_operation207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SUB_in_operation207	= { FOLLOW_SUB_in_operation207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MUL_in_operation214  */
static	ANTLR3_BITWORD FOLLOW_MUL_in_operation214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MUL_in_operation214	= { FOLLOW_MUL_in_operation214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIV_in_operation221  */
static	ANTLR3_BITWORD FOLLOW_DIV_in_operation221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIV_in_operation221	= { FOLLOW_DIV_in_operation221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MOD_in_operation228  */
static	ANTLR3_BITWORD FOLLOW_MOD_in_operation228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MOD_in_operation228	= { FOLLOW_MOD_in_operation228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_operation235  */
static	ANTLR3_BITWORD FOLLOW_AND_in_operation235_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_operation235	= { FOLLOW_AND_in_operation235_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_in_operation242  */
static	ANTLR3_BITWORD FOLLOW_OR_in_operation242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_in_operation242	= { FOLLOW_OR_in_operation242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLT_in_operation249  */
static	ANTLR3_BITWORD FOLLOW_CLT_in_operation249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLT_in_operation249	= { FOLLOW_CLT_in_operation249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CGT_in_operation256  */
static	ANTLR3_BITWORD FOLLOW_CGT_in_operation256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CGT_in_operation256	= { FOLLOW_CGT_in_operation256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLE_in_operation263  */
static	ANTLR3_BITWORD FOLLOW_CLE_in_operation263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLE_in_operation263	= { FOLLOW_CLE_in_operation263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CGE_in_operation270  */
static	ANTLR3_BITWORD FOLLOW_CGE_in_operation270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CGE_in_operation270	= { FOLLOW_CGE_in_operation270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CEQ_in_operation277  */
static	ANTLR3_BITWORD FOLLOW_CEQ_in_operation277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CEQ_in_operation277	= { FOLLOW_CEQ_in_operation277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CNE_in_operation284  */
static	ANTLR3_BITWORD FOLLOW_CNE_in_operation284_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CNE_in_operation284	= { FOLLOW_CNE_in_operation284_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BIT_OR_in_operation291  */
static	ANTLR3_BITWORD FOLLOW_BIT_OR_in_operation291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BIT_OR_in_operation291	= { FOLLOW_BIT_OR_in_operation291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BIT_AND_in_operation298  */
static	ANTLR3_BITWORD FOLLOW_BIT_AND_in_operation298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BIT_AND_in_operation298	= { FOLLOW_BIT_AND_in_operation298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_unary_operation315  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_unary_operation315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_unary_operation315	= { FOLLOW_PLUS_in_unary_operation315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_unary_operation322  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_unary_operation322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_unary_operation322	= { FOLLOW_MINUS_in_unary_operation322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_unary_operation329  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_unary_operation329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_unary_operation329	= { FOLLOW_NOT_in_unary_operation329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_expr348  */
static	ANTLR3_BITWORD FOLLOW_literal_in_expr348_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_expr348	= { FOLLOW_literal_in_expr348_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_defvar_in_expr356  */
static	ANTLR3_BITWORD FOLLOW_defvar_in_expr356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_defvar_in_expr356	= { FOLLOW_defvar_in_expr356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_apply_in_expr364  */
static	ANTLR3_BITWORD FOLLOW_apply_in_expr364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_apply_in_expr364	= { FOLLOW_apply_in_expr364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loop_in_expr372  */
static	ANTLR3_BITWORD FOLLOW_loop_in_expr372_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_loop_in_expr372	= { FOLLOW_loop_in_expr372_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cond_in_expr380  */
static	ANTLR3_BITWORD FOLLOW_cond_in_expr380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cond_in_expr380	= { FOLLOW_cond_in_expr380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_return__in_expr388  */
static	ANTLR3_BITWORD FOLLOW_return__in_expr388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_return__in_expr388	= { FOLLOW_return__in_expr388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interrupt_in_expr396  */
static	ANTLR3_BITWORD FOLLOW_interrupt_in_expr396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_interrupt_in_expr396	= { FOLLOW_interrupt_in_expr396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_preop_in_expr404  */
static	ANTLR3_BITWORD FOLLOW_preop_in_expr404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_preop_in_expr404	= { FOLLOW_preop_in_expr404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_postop_in_expr412  */
static	ANTLR3_BITWORD FOLLOW_postop_in_expr412_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_postop_in_expr412	= { FOLLOW_postop_in_expr412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignop_in_expr420  */
static	ANTLR3_BITWORD FOLLOW_assignop_in_expr420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignop_in_expr420	= { FOLLOW_assignop_in_expr420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assign_in_expr428  */
static	ANTLR3_BITWORD FOLLOW_assign_in_expr428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assign_in_expr428	= { FOLLOW_assign_in_expr428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_expr436  */
static	ANTLR3_BITWORD FOLLOW_block_in_expr436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_expr436	= { FOLLOW_block_in_expr436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unary_operation_in_expr445  */
static	ANTLR3_BITWORD FOLLOW_unary_operation_in_expr445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_unary_operation_in_expr445	= { FOLLOW_unary_operation_in_expr445_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr449  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr449	= { FOLLOW_expr_in_expr449_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_expr461  */
static	ANTLR3_BITWORD FOLLOW_operation_in_expr461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_expr461	= { FOLLOW_operation_in_expr461_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr465  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr465_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDA736FFF70) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr465	= { FOLLOW_expr_in_expr465_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr470  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr470	= { FOLLOW_expr_in_expr470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_expr480  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_expr480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_expr480	= { FOLLOW_DOT_in_expr480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr484  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr484_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDE736FFF70) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr484	= { FOLLOW_expr_in_expr484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessor_in_expr489  */
static	ANTLR3_BITWORD FOLLOW_accessor_in_expr489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_accessor_in_expr489	= { FOLLOW_accessor_in_expr489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_expr500  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_expr500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_expr500	= { FOLLOW_DOT_in_expr500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCOPE_in_expr502  */
static	ANTLR3_BITWORD FOLLOW_SCOPE_in_expr502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SCOPE_in_expr502	= { FOLLOW_SCOPE_in_expr502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_expr504  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_expr504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_expr504	= { FOLLOW_IDENT_in_expr504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRE_OP_in_preop526  */
static	ANTLR3_BITWORD FOLLOW_PRE_OP_in_preop526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PRE_OP_in_preop526	= { FOLLOW_PRE_OP_in_preop526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_preop528  */
static	ANTLR3_BITWORD FOLLOW_operation_in_preop528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_preop528	= { FOLLOW_operation_in_preop528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_preop531  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_preop531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_preop531	= { FOLLOW_DOT_in_preop531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCOPE_in_preop533  */
static	ANTLR3_BITWORD FOLLOW_SCOPE_in_preop533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SCOPE_in_preop533	= { FOLLOW_SCOPE_in_preop533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_preop535  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_preop535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_preop535	= { FOLLOW_IDENT_in_preop535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRE_OP_in_preop545  */
static	ANTLR3_BITWORD FOLLOW_PRE_OP_in_preop545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PRE_OP_in_preop545	= { FOLLOW_PRE_OP_in_preop545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_preop547  */
static	ANTLR3_BITWORD FOLLOW_operation_in_preop547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_preop547	= { FOLLOW_operation_in_preop547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_preop550  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_preop550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_preop550	= { FOLLOW_DOT_in_preop550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_preop554  */
static	ANTLR3_BITWORD FOLLOW_expr_in_preop554_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDE736FFF70) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_preop554	= { FOLLOW_expr_in_preop554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessor_in_preop559  */
static	ANTLR3_BITWORD FOLLOW_accessor_in_preop559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_accessor_in_preop559	= { FOLLOW_accessor_in_preop559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_POST_OP_in_postop580  */
static	ANTLR3_BITWORD FOLLOW_POST_OP_in_postop580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_POST_OP_in_postop580	= { FOLLOW_POST_OP_in_postop580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_postop582  */
static	ANTLR3_BITWORD FOLLOW_operation_in_postop582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_postop582	= { FOLLOW_operation_in_postop582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_postop585  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_postop585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_postop585	= { FOLLOW_DOT_in_postop585_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCOPE_in_postop587  */
static	ANTLR3_BITWORD FOLLOW_SCOPE_in_postop587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SCOPE_in_postop587	= { FOLLOW_SCOPE_in_postop587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_postop589  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_postop589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_postop589	= { FOLLOW_IDENT_in_postop589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_POST_OP_in_postop599  */
static	ANTLR3_BITWORD FOLLOW_POST_OP_in_postop599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_POST_OP_in_postop599	= { FOLLOW_POST_OP_in_postop599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_postop601  */
static	ANTLR3_BITWORD FOLLOW_operation_in_postop601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_postop601	= { FOLLOW_operation_in_postop601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_postop604  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_postop604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_postop604	= { FOLLOW_DOT_in_postop604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_postop608  */
static	ANTLR3_BITWORD FOLLOW_expr_in_postop608_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDE736FFF70) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_postop608	= { FOLLOW_expr_in_postop608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessor_in_postop613  */
static	ANTLR3_BITWORD FOLLOW_accessor_in_postop613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_accessor_in_postop613	= { FOLLOW_accessor_in_postop613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_OP_in_assignop636  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_OP_in_assignop636_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_OP_in_assignop636	= { FOLLOW_ASSIGN_OP_in_assignop636_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_assignop640  */
static	ANTLR3_BITWORD FOLLOW_operation_in_assignop640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_assignop640	= { FOLLOW_operation_in_assignop640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_assignop643  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_assignop643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_assignop643	= { FOLLOW_DOT_in_assignop643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCOPE_in_assignop645  */
static	ANTLR3_BITWORD FOLLOW_SCOPE_in_assignop645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SCOPE_in_assignop645	= { FOLLOW_SCOPE_in_assignop645_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_assignop647  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_assignop647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_assignop647	= { FOLLOW_IDENT_in_assignop647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assignop652  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assignop652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assignop652	= { FOLLOW_expr_in_assignop652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_OP_in_assignop662  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_OP_in_assignop662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_OP_in_assignop662	= { FOLLOW_ASSIGN_OP_in_assignop662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_operation_in_assignop666  */
static	ANTLR3_BITWORD FOLLOW_operation_in_assignop666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_operation_in_assignop666	= { FOLLOW_operation_in_assignop666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_assignop669  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_assignop669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_assignop669	= { FOLLOW_DOT_in_assignop669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assignop673  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assignop673_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDE736FFF70) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assignop673	= { FOLLOW_expr_in_assignop673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessor_in_assignop678  */
static	ANTLR3_BITWORD FOLLOW_accessor_in_assignop678_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_accessor_in_assignop678	= { FOLLOW_accessor_in_assignop678_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assignop684  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assignop684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assignop684	= { FOLLOW_expr_in_assignop684_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_in_assign706  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_in_assign706_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_in_assign706	= { FOLLOW_ASSIGN_in_assign706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_assign709  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_assign709_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_assign709	= { FOLLOW_DOT_in_assign709_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCOPE_in_assign711  */
static	ANTLR3_BITWORD FOLLOW_SCOPE_in_assign711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SCOPE_in_assign711	= { FOLLOW_SCOPE_in_assign711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_assign713  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_assign713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_assign713	= { FOLLOW_IDENT_in_assign713_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assign718  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assign718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assign718	= { FOLLOW_expr_in_assign718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_in_assign728  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_in_assign728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_in_assign728	= { FOLLOW_ASSIGN_in_assign728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_assign731  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_assign731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_assign731	= { FOLLOW_DOT_in_assign731_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assign735  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assign735_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDE736FFF70) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assign735	= { FOLLOW_expr_in_assign735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessor_in_assign740  */
static	ANTLR3_BITWORD FOLLOW_accessor_in_assign740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_accessor_in_assign740	= { FOLLOW_accessor_in_assign740_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assign746  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assign746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assign746	= { FOLLOW_expr_in_assign746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_accessor768  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_accessor768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_accessor768	= { FOLLOW_IDENT_in_accessor768_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_accessor776  */
static	ANTLR3_BITWORD FOLLOW_expr_in_accessor776_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_accessor776	= { FOLLOW_expr_in_accessor776_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_APPLY_in_apply798  */
static	ANTLR3_BITWORD FOLLOW_APPLY_in_apply798_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_APPLY_in_apply798	= { FOLLOW_APPLY_in_apply798_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_apply801  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_apply801_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_apply801	= { FOLLOW_DOT_in_apply801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCOPE_in_apply803  */
static	ANTLR3_BITWORD FOLLOW_SCOPE_in_apply803_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SCOPE_in_apply803	= { FOLLOW_SCOPE_in_apply803_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_apply805  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_apply805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_apply805	= { FOLLOW_IDENT_in_apply805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arglist_in_apply810  */
static	ANTLR3_BITWORD FOLLOW_arglist_in_apply810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arglist_in_apply810	= { FOLLOW_arglist_in_apply810_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_APPLY_in_apply821  */
static	ANTLR3_BITWORD FOLLOW_APPLY_in_apply821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_APPLY_in_apply821	= { FOLLOW_APPLY_in_apply821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_apply824  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_apply824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_apply824	= { FOLLOW_DOT_in_apply824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_apply828  */
static	ANTLR3_BITWORD FOLLOW_expr_in_apply828_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDE736FFF70) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_apply828	= { FOLLOW_expr_in_apply828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_accessor_in_apply833  */
static	ANTLR3_BITWORD FOLLOW_accessor_in_apply833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_accessor_in_apply833	= { FOLLOW_accessor_in_apply833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arglist_in_apply839  */
static	ANTLR3_BITWORD FOLLOW_arglist_in_apply839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arglist_in_apply839	= { FOLLOW_arglist_in_apply839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_APPLY_in_apply850  */
static	ANTLR3_BITWORD FOLLOW_APPLY_in_apply850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_APPLY_in_apply850	= { FOLLOW_APPLY_in_apply850_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_closure_in_apply852  */
static	ANTLR3_BITWORD FOLLOW_closure_in_apply852_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_closure_in_apply852	= { FOLLOW_closure_in_apply852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arglist_in_apply857  */
static	ANTLR3_BITWORD FOLLOW_arglist_in_apply857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arglist_in_apply857	= { FOLLOW_arglist_in_apply857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COND_in_cond880  */
static	ANTLR3_BITWORD FOLLOW_COND_in_cond880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COND_in_cond880	= { FOLLOW_COND_in_cond880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_cond884  */
static	ANTLR3_BITWORD FOLLOW_expr_in_cond884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_cond884	= { FOLLOW_expr_in_cond884_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_cond889  */
static	ANTLR3_BITWORD FOLLOW_block_in_cond889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000600000) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_cond889	= { FOLLOW_block_in_cond889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_cond897  */
static	ANTLR3_BITWORD FOLLOW_block_in_cond897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_cond897	= { FOLLOW_block_in_cond897_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cond_in_cond909  */
static	ANTLR3_BITWORD FOLLOW_cond_in_cond909_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_cond_in_cond909	= { FOLLOW_cond_in_cond909_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_loop939  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_loop939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_loop939	= { FOLLOW_FOR_in_loop939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_loop943  */
static	ANTLR3_BITWORD FOLLOW_block_in_loop943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_loop943	= { FOLLOW_block_in_loop943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_loop948  */
static	ANTLR3_BITWORD FOLLOW_block_in_loop948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_loop948	= { FOLLOW_block_in_loop948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_loop953  */
static	ANTLR3_BITWORD FOLLOW_block_in_loop953_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_loop953	= { FOLLOW_block_in_loop953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_loop958  */
static	ANTLR3_BITWORD FOLLOW_block_in_loop958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_loop958	= { FOLLOW_block_in_loop958_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LITERAL_in_literal980  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LITERAL_in_literal980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LITERAL_in_literal980	= { FOLLOW_TRUE_LITERAL_in_literal980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LITERAL_in_literal988  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LITERAL_in_literal988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LITERAL_in_literal988	= { FOLLOW_FALSE_LITERAL_in_literal988_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NULL_LITERAL_in_literal996  */
static	ANTLR3_BITWORD FOLLOW_NULL_LITERAL_in_literal996_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NULL_LITERAL_in_literal996	= { FOLLOW_NULL_LITERAL_in_literal996_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_LITERAL_in_literal1004  */
static	ANTLR3_BITWORD FOLLOW_HEX_LITERAL_in_literal1004_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_LITERAL_in_literal1004	= { FOLLOW_HEX_LITERAL_in_literal1004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OCT_LITERAL_in_literal1012  */
static	ANTLR3_BITWORD FOLLOW_OCT_LITERAL_in_literal1012_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OCT_LITERAL_in_literal1012	= { FOLLOW_OCT_LITERAL_in_literal1012_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_LITERAL_in_literal1020  */
static	ANTLR3_BITWORD FOLLOW_INT_LITERAL_in_literal1020_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_LITERAL_in_literal1020	= { FOLLOW_INT_LITERAL_in_literal1020_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOAT_LITERAL_in_literal1028  */
static	ANTLR3_BITWORD FOLLOW_FLOAT_LITERAL_in_literal1028_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOAT_LITERAL_in_literal1028	= { FOLLOW_FLOAT_LITERAL_in_literal1028_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_SINGLE_in_literal1036  */
static	ANTLR3_BITWORD FOLLOW_STRING_SINGLE_in_literal1036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_SINGLE_in_literal1036	= { FOLLOW_STRING_SINGLE_in_literal1036_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_DOUBLE_in_literal1044  */
static	ANTLR3_BITWORD FOLLOW_STRING_DOUBLE_in_literal1044_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_DOUBLE_in_literal1044	= { FOLLOW_STRING_DOUBLE_in_literal1044_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_array_in_literal1052  */
static	ANTLR3_BITWORD FOLLOW_array_in_literal1052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_array_in_literal1052	= { FOLLOW_array_in_literal1052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_in_literal1060  */
static	ANTLR3_BITWORD FOLLOW_object_in_literal1060_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_in_literal1060	= { FOLLOW_object_in_literal1060_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_closure_in_literal1068  */
static	ANTLR3_BITWORD FOLLOW_closure_in_literal1068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_closure_in_literal1068	= { FOLLOW_closure_in_literal1068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SELF_in_literal1076  */
static	ANTLR3_BITWORD FOLLOW_SELF_in_literal1076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SELF_in_literal1076	= { FOLLOW_SELF_in_literal1076_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RETURN_in_return_1096  */
static	ANTLR3_BITWORD FOLLOW_RETURN_in_return_1096_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RETURN_in_return_1096	= { FOLLOW_RETURN_in_return_1096_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_return_1098  */
static	ANTLR3_BITWORD FOLLOW_expr_in_return_1098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_return_1098	= { FOLLOW_expr_in_return_1098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTERRUPT_in_interrupt1121  */
static	ANTLR3_BITWORD FOLLOW_INTERRUPT_in_interrupt1121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INTERRUPT_in_interrupt1121	= { FOLLOW_INTERRUPT_in_interrupt1121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_interrupt1123  */
static	ANTLR3_BITWORD FOLLOW_expr_in_interrupt1123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_interrupt1123	= { FOLLOW_expr_in_interrupt1123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OBJECT_in_object1151  */
static	ANTLR3_BITWORD FOLLOW_OBJECT_in_object1151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OBJECT_in_object1151	= { FOLLOW_OBJECT_in_object1151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_pair_in_object1156  */
static	ANTLR3_BITWORD FOLLOW_object_pair_in_object1156_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_object_pair_in_object1156	= { FOLLOW_object_pair_in_object1156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PAIR_in_object_pair1182  */
static	ANTLR3_BITWORD FOLLOW_PAIR_in_object_pair1182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PAIR_in_object_pair1182	= { FOLLOW_PAIR_in_object_pair1182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_object_pair1184  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_object_pair1184_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDA736FFF70) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_object_pair1184	= { FOLLOW_IDENT_in_object_pair1184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_object_pair1188  */
static	ANTLR3_BITWORD FOLLOW_expr_in_object_pair1188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_object_pair1188	= { FOLLOW_expr_in_object_pair1188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ARRAY_in_array1216  */
static	ANTLR3_BITWORD FOLLOW_ARRAY_in_array1216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ARRAY_in_array1216	= { FOLLOW_ARRAY_in_array1216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_array1222  */
static	ANTLR3_BITWORD FOLLOW_expr_in_array1222_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDA736FFF78) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_array1222	= { FOLLOW_expr_in_array1222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ARGS_in_arglist1256  */
static	ANTLR3_BITWORD FOLLOW_ARGS_in_arglist1256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ARGS_in_arglist1256	= { FOLLOW_ARGS_in_arglist1256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_arglist1261  */
static	ANTLR3_BITWORD FOLLOW_expr_in_arglist1261_bits[]	= { ANTLR3_UINT64_LIT(0x3ADEDDDA736FFF78) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_arglist1261	= { FOLLOW_expr_in_arglist1261_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start prog
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:35:1: prog returns [ Handler<donut::Source> code ] : closure[$code.get()] ;
 */
static Handler<donut::Source>
prog(pCompiler ctx)
{
    Handler<donut::Source> code;


    Compiler_closure_return closure1;
    #undef	RETURN_TYPE_closure1
    #define	RETURN_TYPE_closure1 Compiler_closure_return

    /* Initialize rule variables
     */


    	code= Handler<donut::Source>( new donut::Source() );


    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:39:2: ( closure[$code.get()] )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:39:4: closure[$code.get()]
        {
            FOLLOWPUSH(FOLLOW_closure_in_prog64);
            closure1=closure(ctx, 
            code
            .get());

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprogEx;
            }


            {

                		code
                ->setEntrypointID( closure1.closureNo
                 );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return code;
}
/* $ANTLR end prog */

/**
 * $ANTLR start closure
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:45:1: closure[ donut::Source* code] returns [ std::vector<donut::Instruction> asmlist, unsigned int closureNo ] : ^( CLOS vars[$code] block[$code] ) ;
 */
static Compiler_closure_return
closure(pCompiler ctx, donut::Source* code)
{
    Compiler_closure_return retval;


    std::vector<std::string> vars2;
    #undef	RETURN_TYPE_vars2
    #define	RETURN_TYPE_vars2 std::vector<std::string>

    std::vector<donut::Instruction> block3;
    #undef	RETURN_TYPE_block3
    #define	RETURN_TYPE_block3 std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:46:2: ( ^( CLOS vars[$code] block[$code] ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:46:4: ^( CLOS vars[$code] block[$code] )
        {
             MATCHT(CLOS, &FOLLOW_CLOS_in_closure86);
            if  (HASEXCEPTION())
            {
                goto ruleclosureEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleclosureEx;
            }

            FOLLOWPUSH(FOLLOW_vars_in_closure88);
            vars2=vars(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleclosureEx;
            }


            FOLLOWPUSH(FOLLOW_block_in_closure91);
            block3=block(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleclosureEx;
            }


            {

                		Handler<donut::Closure> closure = Handler<donut::Closure>(new donut::Closure(vars2
                , block3
                ));
                		retval.closureNo= code->constCode<Handler<donut::Closure> >(closure);

                		retval.asmlist
                .push_back(Inst::Push | retval.closureNo
                );
                	
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleclosureEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleclosureEx; /* Prevent compiler warnings */
    ruleclosureEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end closure */

/**
 * $ANTLR start vars
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:55:1: vars[ donut::Source* code ] returns [ std::vector<std::string> asmlist ] : ^( VARS ( IDENT )* ) ;
 */
static std::vector<std::string>
vars(pCompiler ctx, donut::Source* code)
{
    std::vector<std::string> asmlist;


    pANTLR3_BASE_TREE    IDENT4;

    /* Initialize rule variables
     */

    IDENT4       = NULL;

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:56:2: ( ^( VARS ( IDENT )* ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:56:4: ^( VARS ( IDENT )* )
        {
             MATCHT(VARS, &FOLLOW_VARS_in_vars116);
            if  (HASEXCEPTION())
            {
                goto rulevarsEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulevarsEx;
                }

                // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:56:11: ( IDENT )*

                for (;;)
                {
                    int alt1=2;
                    switch ( LA(1) )
                    {
                    case IDENT:
                    	{
                    		alt1=1;
                    	}
                        break;

                    }

                    switch (alt1)
                    {
                	case 1:
                	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:56:12: IDENT
                	    {
                	        IDENT4 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_vars119);
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulevarsEx;
                	        }


                	        {

                	            		asmlist
                	            .push_back(createStringFromString((IDENT4->getText(IDENT4))));
                	            	
                	        }


                	    }
                	    break;

                	default:
                	    goto loop1;	/* break out of the loop */
                	    break;
                    }
                }
                loop1: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulevarsEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevarsEx; /* Prevent compiler warnings */
    rulevarsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end vars */

/**
 * $ANTLR start defvar
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:60:1: defvar[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( VAR IDENT (val= expr[code] )? ) ;
 */
static std::vector<donut::Instruction>
defvar(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT5;
    std::vector<donut::Instruction> val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    IDENT5       = NULL;

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:61:2: ( ^( VAR IDENT (val= expr[code] )? ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:61:4: ^( VAR IDENT (val= expr[code] )? )
        {
             MATCHT(VAR, &FOLLOW_VAR_in_defvar139);
            if  (HASEXCEPTION())
            {
                goto ruledefvarEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefvarEx;
            }

            IDENT5 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_defvar141);
            if  (HASEXCEPTION())
            {
                goto ruledefvarEx;
            }


            // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:61:19: (val= expr[code] )?
            {
                int alt2=2;
                switch ( LA(1) )
                {
                    case ADD:
                    case AND:
                    case APPLY:
                    case ARRAY:
                    case ASSIGN:
                    case ASSIGN_OP:
                    case BIT_AND:
                    case BIT_OR:
                    case CEQ:
                    case CGE:
                    case CGT:
                    case CLE:
                    case CLOS:
                    case CLT:
                    case CNE:
                    case COND:
                    case CONT:
                    case DIV:
                    case DOT:
                    case FALSE_LITERAL:
                    case FLOAT_LITERAL:
                    case FOR:
                    case HEX_LITERAL:
                    case INTERRUPT:
                    case INT_LITERAL:
                    case MINUS:
                    case MOD:
                    case MUL:
                    case NOT:
                    case NULL_LITERAL:
                    case OBJECT:
                    case OCT_LITERAL:
                    case OR:
                    case PLUS:
                    case POST_OP:
                    case PRE_OP:
                    case RETURN:
                    case SELF:
                    case STRING_DOUBLE:
                    case STRING_SINGLE:
                    case SUB:
                    case TRUE_LITERAL:
                    case VAR:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2)
                {
            	case 1:
            	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:61:19: val= expr[code]
            	    {
            	        FOLLOWPUSH(FOLLOW_expr_in_defvar145);
            	        val=expr(ctx, code);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefvarEx;
            	        }


            	    }
            	    break;

                }
            }

            {

                		if( !(val
                .empty()) ) {
                			asmlist
                .insert(asmlist
                .end(), val
                .begin(), val
                .end());
                		}else{
                			asmlist
                .push_back(Inst::Push | code->constCode<std::nullptr_t>(nullptr));
                		}
                		
                asmlist
                .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT5->getText(IDENT5)))));
                		
                asmlist
                .push_back(Inst::DefVar);
                	
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefvarEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruledefvarEx; /* Prevent compiler warnings */
    ruledefvarEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end defvar */

/**
 * $ANTLR start block
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:73:1: block[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( CONT (ex= expr[$code] )* ) ;
 */
static std::vector<donut::Instruction>
block(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    std::vector<donut::Instruction> ex;
    #undef	RETURN_TYPE_ex
    #define	RETURN_TYPE_ex std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:83:2: ( ^( CONT (ex= expr[$code] )* ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:83:4: ^( CONT (ex= expr[$code] )* )
        {
             MATCHT(CONT, &FOLLOW_CONT_in_block173);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

                // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:83:11: (ex= expr[$code] )*

                for (;;)
                {
                    int alt3=2;
                    switch ( LA(1) )
                    {
                    case ADD:
                    case AND:
                    case APPLY:
                    case ARRAY:
                    case ASSIGN:
                    case ASSIGN_OP:
                    case BIT_AND:
                    case BIT_OR:
                    case CEQ:
                    case CGE:
                    case CGT:
                    case CLE:
                    case CLOS:
                    case CLT:
                    case CNE:
                    case COND:
                    case CONT:
                    case DIV:
                    case DOT:
                    case FALSE_LITERAL:
                    case FLOAT_LITERAL:
                    case FOR:
                    case HEX_LITERAL:
                    case INTERRUPT:
                    case INT_LITERAL:
                    case MINUS:
                    case MOD:
                    case MUL:
                    case NOT:
                    case NULL_LITERAL:
                    case OBJECT:
                    case OCT_LITERAL:
                    case OR:
                    case PLUS:
                    case POST_OP:
                    case PRE_OP:
                    case RETURN:
                    case SELF:
                    case STRING_DOUBLE:
                    case STRING_SINGLE:
                    case SUB:
                    case TRUE_LITERAL:
                    case VAR:
                    	{
                    		alt3=1;
                    	}
                        break;

                    }

                    switch (alt3)
                    {
                	case 1:
                	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:83:12: ex= expr[$code]
                	    {
                	        FOLLOWPUSH(FOLLOW_expr_in_block178);
                	        ex=expr(ctx, code);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }


                	        {

                	            		asmlist
                	            .insert(asmlist
                	            .end(), ex
                	            .begin(), ex
                	            .end());
                	            		asmlist
                	            .push_back(Inst::Pop | 0);
                	            	
                	        }


                	    }
                	    break;

                	default:
                	    goto loop3;	/* break out of the loop */
                	    break;
                    }
                }
                loop3: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	if( asmlist
                    .empty() ){
                    		//null
                    			asmlist
                    .push_back(Inst::Push | code->constCode<std::nullptr_t>(nullptr));
                    	}else{
                    		//pop
                    		
                    asmlist
                    .erase(asmlist
                    .end()-1);
                    	}

                }
            }


    return asmlist;
}
/* $ANTLR end block */

/**
 * $ANTLR start operation
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:90:1: operation returns [ std::string sym ] : ( ADD | SUB | MUL | DIV | MOD | AND | OR | CLT | CGT | CLE | CGE | CEQ | CNE | BIT_OR | BIT_AND );
 */
static std::string
operation(pCompiler ctx)
{
    std::string sym;


    /* Initialize rule variables
     */

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:91:2: ( ADD | SUB | MUL | DIV | MOD | AND | OR | CLT | CGT | CLE | CGE | CEQ | CNE | BIT_OR | BIT_AND )

            ANTLR3_UINT32 alt4;

            alt4=15;

            switch ( LA(1) )
            {
            case ADD:
            	{
            		alt4=1;
            	}
                break;
            case SUB:
            	{
            		alt4=2;
            	}
                break;
            case MUL:
            	{
            		alt4=3;
            	}
                break;
            case DIV:
            	{
            		alt4=4;
            	}
                break;
            case MOD:
            	{
            		alt4=5;
            	}
                break;
            case AND:
            	{
            		alt4=6;
            	}
                break;
            case OR:
            	{
            		alt4=7;
            	}
                break;
            case CLT:
            	{
            		alt4=8;
            	}
                break;
            case CGT:
            	{
            		alt4=9;
            	}
                break;
            case CLE:
            	{
            		alt4=10;
            	}
                break;
            case CGE:
            	{
            		alt4=11;
            	}
                break;
            case CEQ:
            	{
            		alt4=12;
            	}
                break;
            case CNE:
            	{
            		alt4=13;
            	}
                break;
            case BIT_OR:
            	{
            		alt4=14;
            	}
                break;
            case BIT_AND:
            	{
            		alt4=15;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto ruleoperationEx;

            }

            switch (alt4)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:91:4: ADD
        	    {
        	         MATCHT(ADD, &FOLLOW_ADD_in_operation200);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym="opAdd"; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:92:4: SUB
        	    {
        	         MATCHT(SUB, &FOLLOW_SUB_in_operation207);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym="opSub"; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:93:4: MUL
        	    {
        	         MATCHT(MUL, &FOLLOW_MUL_in_operation214);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opMul"; 
        	        }


        	    }
        	    break;
        	case 4:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:94:4: DIV
        	    {
        	         MATCHT(DIV, &FOLLOW_DIV_in_operation221);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opDiv"; 
        	        }


        	    }
        	    break;
        	case 5:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:95:4: MOD
        	    {
        	         MATCHT(MOD, &FOLLOW_MOD_in_operation228);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opMod"; 
        	        }


        	    }
        	    break;
        	case 6:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:96:4: AND
        	    {
        	         MATCHT(AND, &FOLLOW_AND_in_operation235);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opAnd"; 
        	        }


        	    }
        	    break;
        	case 7:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:97:4: OR
        	    {
        	         MATCHT(OR, &FOLLOW_OR_in_operation242);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opOr"; 
        	        }


        	    }
        	    break;
        	case 8:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:98:4: CLT
        	    {
        	         MATCHT(CLT, &FOLLOW_CLT_in_operation249);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opLt"; 
        	        }


        	    }
        	    break;
        	case 9:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:99:4: CGT
        	    {
        	         MATCHT(CGT, &FOLLOW_CGT_in_operation256);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opGt"; 
        	        }


        	    }
        	    break;
        	case 10:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:100:4: CLE
        	    {
        	         MATCHT(CLE, &FOLLOW_CLE_in_operation263);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opLe"; 
        	        }


        	    }
        	    break;
        	case 11:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:101:4: CGE
        	    {
        	         MATCHT(CGE, &FOLLOW_CGE_in_operation270);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opGe"; 
        	        }


        	    }
        	    break;
        	case 12:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:102:4: CEQ
        	    {
        	         MATCHT(CEQ, &FOLLOW_CEQ_in_operation277);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opEq"; 
        	        }


        	    }
        	    break;
        	case 13:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:103:4: CNE
        	    {
        	         MATCHT(CNE, &FOLLOW_CNE_in_operation284);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	             sym = "opNe"; 
        	        }


        	    }
        	    break;
        	case 14:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:104:4: BIT_OR
        	    {
        	         MATCHT(BIT_OR, &FOLLOW_BIT_OR_in_operation291);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	            sym="opBitOr";
        	        }


        	    }
        	    break;
        	case 15:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:105:4: BIT_AND
        	    {
        	         MATCHT(BIT_AND, &FOLLOW_BIT_AND_in_operation298);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoperationEx;
        	        }


        	        {
        	            sym="opBitAnd";
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleoperationEx; /* Prevent compiler warnings */
    ruleoperationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return sym;
}
/* $ANTLR end operation */

/**
 * $ANTLR start unary_operation
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:108:1: unary_operation returns [ std::string sym ] : ( PLUS | MINUS | NOT );
 */
static std::string
unary_operation(pCompiler ctx)
{
    std::string sym;


    /* Initialize rule variables
     */

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:109:2: ( PLUS | MINUS | NOT )

            ANTLR3_UINT32 alt5;

            alt5=3;

            switch ( LA(1) )
            {
            case PLUS:
            	{
            		alt5=1;
            	}
                break;
            case MINUS:
            	{
            		alt5=2;
            	}
                break;
            case NOT:
            	{
            		alt5=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto ruleunary_operationEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:109:4: PLUS
        	    {
        	         MATCHT(PLUS, &FOLLOW_PLUS_in_unary_operation315);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_operationEx;
        	        }


        	        {
        	             sym="opPlus"; 
        	        }


        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:110:4: MINUS
        	    {
        	         MATCHT(MINUS, &FOLLOW_MINUS_in_unary_operation322);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_operationEx;
        	        }


        	        {
        	             sym="opMinus"; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:111:4: NOT
        	    {
        	         MATCHT(NOT, &FOLLOW_NOT_in_unary_operation329);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunary_operationEx;
        	        }


        	        {
        	             sym="opNot"; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleunary_operationEx; /* Prevent compiler warnings */
    ruleunary_operationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return sym;
}
/* $ANTLR end unary_operation */

/**
 * $ANTLR start expr
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:114:1: expr[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ( literal[$code] | defvar[$code] | apply[$code] | loop[$code] | cond[$code] | return_[$code] | interrupt[$code] | preop[$code] | postop[$code] | assignop[$code] | assign[$code] | block[$code] | ^( unary_operation uobj= expr[$code] ) | ^(biop= operation blhs= expr[$code] brhs= expr[$code] ) | ^( DOT dexpr= expr[$code] ac= accessor[$code] ) | ^( DOT SCOPE IDENT ) );
 */
static std::vector<donut::Instruction>
expr(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT19;
    std::vector<donut::Instruction> uobj;
    #undef	RETURN_TYPE_uobj
    #define	RETURN_TYPE_uobj std::vector<donut::Instruction>

    std::string biop;
    #undef	RETURN_TYPE_biop
    #define	RETURN_TYPE_biop std::string

    std::vector<donut::Instruction> blhs;
    #undef	RETURN_TYPE_blhs
    #define	RETURN_TYPE_blhs std::vector<donut::Instruction>

    std::vector<donut::Instruction> brhs;
    #undef	RETURN_TYPE_brhs
    #define	RETURN_TYPE_brhs std::vector<donut::Instruction>

    std::vector<donut::Instruction> dexpr;
    #undef	RETURN_TYPE_dexpr
    #define	RETURN_TYPE_dexpr std::vector<donut::Instruction>

    std::vector<donut::Instruction> ac;
    #undef	RETURN_TYPE_ac
    #define	RETURN_TYPE_ac std::vector<donut::Instruction>

    std::vector<donut::Instruction> literal6;
    #undef	RETURN_TYPE_literal6
    #define	RETURN_TYPE_literal6 std::vector<donut::Instruction>

    std::vector<donut::Instruction> defvar7;
    #undef	RETURN_TYPE_defvar7
    #define	RETURN_TYPE_defvar7 std::vector<donut::Instruction>

    std::vector<donut::Instruction> apply8;
    #undef	RETURN_TYPE_apply8
    #define	RETURN_TYPE_apply8 std::vector<donut::Instruction>

    std::vector<donut::Instruction> loop9;
    #undef	RETURN_TYPE_loop9
    #define	RETURN_TYPE_loop9 std::vector<donut::Instruction>

    std::vector<donut::Instruction> cond10;
    #undef	RETURN_TYPE_cond10
    #define	RETURN_TYPE_cond10 std::vector<donut::Instruction>

    std::vector<donut::Instruction> return_11;
    #undef	RETURN_TYPE_return_11
    #define	RETURN_TYPE_return_11 std::vector<donut::Instruction>

    std::vector<donut::Instruction> interrupt12;
    #undef	RETURN_TYPE_interrupt12
    #define	RETURN_TYPE_interrupt12 std::vector<donut::Instruction>

    std::vector<donut::Instruction> preop13;
    #undef	RETURN_TYPE_preop13
    #define	RETURN_TYPE_preop13 std::vector<donut::Instruction>

    std::vector<donut::Instruction> postop14;
    #undef	RETURN_TYPE_postop14
    #define	RETURN_TYPE_postop14 std::vector<donut::Instruction>

    std::vector<donut::Instruction> assignop15;
    #undef	RETURN_TYPE_assignop15
    #define	RETURN_TYPE_assignop15 std::vector<donut::Instruction>

    std::vector<donut::Instruction> assign16;
    #undef	RETURN_TYPE_assign16
    #define	RETURN_TYPE_assign16 std::vector<donut::Instruction>

    std::vector<donut::Instruction> block17;
    #undef	RETURN_TYPE_block17
    #define	RETURN_TYPE_block17 std::vector<donut::Instruction>

    std::string unary_operation18;
    #undef	RETURN_TYPE_unary_operation18
    #define	RETURN_TYPE_unary_operation18 std::string

    /* Initialize rule variables
     */

    IDENT19       = NULL;

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:115:2: ( literal[$code] | defvar[$code] | apply[$code] | loop[$code] | cond[$code] | return_[$code] | interrupt[$code] | preop[$code] | postop[$code] | assignop[$code] | assign[$code] | block[$code] | ^( unary_operation uobj= expr[$code] ) | ^(biop= operation blhs= expr[$code] brhs= expr[$code] ) | ^( DOT dexpr= expr[$code] ac= accessor[$code] ) | ^( DOT SCOPE IDENT ) )

            ANTLR3_UINT32 alt6;

            alt6=16;

            switch ( LA(1) )
            {
            case ARRAY:
            case CLOS:
            case FALSE_LITERAL:
            case FLOAT_LITERAL:
            case HEX_LITERAL:
            case INT_LITERAL:
            case NULL_LITERAL:
            case OBJECT:
            case OCT_LITERAL:
            case SELF:
            case STRING_DOUBLE:
            case STRING_SINGLE:
            case TRUE_LITERAL:
            	{
            		alt6=1;
            	}
                break;
            case VAR:
            	{
            		alt6=2;
            	}
                break;
            case APPLY:
            	{
            		alt6=3;
            	}
                break;
            case FOR:
            	{
            		alt6=4;
            	}
                break;
            case COND:
            	{
            		alt6=5;
            	}
                break;
            case RETURN:
            	{
            		alt6=6;
            	}
                break;
            case INTERRUPT:
            	{
            		alt6=7;
            	}
                break;
            case PRE_OP:
            	{
            		alt6=8;
            	}
                break;
            case POST_OP:
            	{
            		alt6=9;
            	}
                break;
            case ASSIGN_OP:
            	{
            		alt6=10;
            	}
                break;
            case ASSIGN:
            	{
            		alt6=11;
            	}
                break;
            case CONT:
            	{
            		alt6=12;
            	}
                break;
            case MINUS:
            case NOT:
            case PLUS:
            	{
            		alt6=13;
            	}
                break;
            case ADD:
            case AND:
            case BIT_AND:
            case BIT_OR:
            case CEQ:
            case CGE:
            case CGT:
            case CLE:
            case CLT:
            case CNE:
            case DIV:
            case MOD:
            case MUL:
            case OR:
            case SUB:
            	{
            		alt6=14;
            	}
                break;
            case DOT:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case SCOPE:
            					{
            						alt6=16;
            					}
            				    break;
            				case ADD:
            				case AND:
            				case APPLY:
            				case ARRAY:
            				case ASSIGN:
            				case ASSIGN_OP:
            				case BIT_AND:
            				case BIT_OR:
            				case CEQ:
            				case CGE:
            				case CGT:
            				case CLE:
            				case CLOS:
            				case CLT:
            				case CNE:
            				case COND:
            				case CONT:
            				case DIV:
            				case DOT:
            				case FALSE_LITERAL:
            				case FLOAT_LITERAL:
            				case FOR:
            				case HEX_LITERAL:
            				case INTERRUPT:
            				case INT_LITERAL:
            				case MINUS:
            				case MOD:
            				case MUL:
            				case NOT:
            				case NULL_LITERAL:
            				case OBJECT:
            				case OCT_LITERAL:
            				case OR:
            				case PLUS:
            				case POST_OP:
            				case PRE_OP:
            				case RETURN:
            				case SELF:
            				case STRING_DOUBLE:
            				case STRING_SINGLE:
            				case SUB:
            				case TRUE_LITERAL:
            				case VAR:
            					{
            						alt6=15;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 6;
            				    EXCEPTION->state        = 16;


            				    goto ruleexprEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 6;
            		    EXCEPTION->state        = 15;


            		    goto ruleexprEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto ruleexprEx;

            }

            switch (alt6)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:115:4: literal[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_literal_in_expr348);
        	        literal6=literal(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	             asmlist
        	            .swap(literal6
        	            ); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:116:4: defvar[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_defvar_in_expr356);
        	        defvar7=defvar(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	             asmlist
        	            .swap(defvar7
        	            ); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:117:4: apply[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_apply_in_expr364);
        	        apply8=apply(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	             asmlist
        	            .swap(apply8
        	            ); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:118:4: loop[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_loop_in_expr372);
        	        loop9=loop(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	             asmlist
        	            .swap(loop9
        	            ); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:119:4: cond[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_cond_in_expr380);
        	        cond10=cond(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	             asmlist
        	            .swap(cond10
        	            ); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:120:4: return_[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_return__in_expr388);
        	        return_11=return_(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	             asmlist
        	            .swap(return_11
        	            ); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:121:4: interrupt[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_interrupt_in_expr396);
        	        interrupt12=interrupt(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	             asmlist
        	            .swap(interrupt12
        	            ); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:122:4: preop[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_preop_in_expr404);
        	        preop13=preop(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	            asmlist
        	            .swap(preop13
        	            );
        	        }


        	    }
        	    break;
        	case 9:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:123:4: postop[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_postop_in_expr412);
        	        postop14=postop(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	            asmlist
        	            .swap(postop14
        	            );
        	        }


        	    }
        	    break;
        	case 10:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:124:4: assignop[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_assignop_in_expr420);
        	        assignop15=assignop(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	            asmlist
        	            .swap(assignop15
        	            );
        	        }


        	    }
        	    break;
        	case 11:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:125:4: assign[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_assign_in_expr428);
        	        assign16=assign(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	            asmlist
        	            .swap(assign16
        	            );
        	        }


        	    }
        	    break;
        	case 12:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:126:4: block[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_block_in_expr436);
        	        block17=block(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {
        	            asmlist
        	            .swap(block17
        	            );
        	        }


        	    }
        	    break;
        	case 13:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:127:4: ^( unary_operation uobj= expr[$code] )
        	    {
        	        FOLLOWPUSH(FOLLOW_unary_operation_in_expr445);
        	        unary_operation18=unary_operation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr449);
        	        uobj=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {

        	            		asmlist
        	            .insert(asmlist
        	            .end(), uobj
        	            .begin(), uobj
        	            .end());
        	            		//
        	            		asmlist
        	            .push_back(Inst::PushCopy | 0);
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(
        	            unary_operation18
        	            ));
        	            		asmlist
        	            .push_back(Inst::LoadObj);
        	            		//
        	            		asmlist
        	            .push_back(Inst::Apply | 0);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }



        	    }
        	    break;
        	case 14:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:136:4: ^(biop= operation blhs= expr[$code] brhs= expr[$code] )
        	    {
        	        FOLLOWPUSH(FOLLOW_operation_in_expr461);
        	        biop=operation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr465);
        	        blhs=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expr_in_expr470);
        	        brhs=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        {

        	            		//lhs
        	            		asmlist
        	            .insert(asmlist
        	            .end(), blhs
        	            .begin(), blhs
        	            .end());
        	            		//
        	            		asmlist
        	            .push_back(Inst::PushCopy);
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(
        	            biop
        	            ));
        	            		asmlist
        	            .push_back(Inst::LoadObj);
        	            		//rhs
        	            		asmlist
        	            .insert(asmlist
        	            .end(), brhs
        	            .begin(), brhs
        	            .end());
        	            		//
        	            		asmlist
        	            .push_back(Inst::Apply | 1);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }



        	    }
        	    break;
        	case 15:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:148:4: ^( DOT dexpr= expr[$code] ac= accessor[$code] )
        	    {
        	         MATCHT(DOT, &FOLLOW_DOT_in_expr480);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr484);
        	        dexpr=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_accessor_in_expr489);
        	        ac=accessor(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }



        	        {

        	            		asmlist
        	            .insert(asmlist
        	            .end(), dexpr
        	            .begin(), dexpr
        	            .end());
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ac
        	            .begin(), ac
        	            .end());
        	            		asmlist
        	            .push_back(Inst::LoadObj);
        	            	
        	        }


        	    }
        	    break;
        	case 16:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:154:4: ^( DOT SCOPE IDENT )
        	    {
        	         MATCHT(DOT, &FOLLOW_DOT_in_expr500);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }

        	         MATCHT(SCOPE, &FOLLOW_SCOPE_in_expr502);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        IDENT19 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_expr504);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }



        	        {

        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT19->getText(IDENT19)))));
        	            		
        	            asmlist
        	            .push_back(Inst::SearchScope);
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT19->getText(IDENT19)))));
        	            		
        	            asmlist
        	            .push_back(Inst::LoadObj);
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end expr */

/**
 * $ANTLR start preop
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:163:1: preop[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ( ^( PRE_OP operation ^( DOT SCOPE IDENT ) ) | ^( PRE_OP operation ^( DOT preexpr= expr[$code] ac= accessor[$code] ) ) );
 */
static std::vector<donut::Instruction>
preop(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT20;
    std::vector<donut::Instruction> preexpr;
    #undef	RETURN_TYPE_preexpr
    #define	RETURN_TYPE_preexpr std::vector<donut::Instruction>

    std::vector<donut::Instruction> ac;
    #undef	RETURN_TYPE_ac
    #define	RETURN_TYPE_ac std::vector<donut::Instruction>

    std::string operation21;
    #undef	RETURN_TYPE_operation21
    #define	RETURN_TYPE_operation21 std::string

    std::string operation22;
    #undef	RETURN_TYPE_operation22
    #define	RETURN_TYPE_operation22 std::string

    /* Initialize rule variables
     */

    IDENT20       = NULL;

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:164:2: ( ^( PRE_OP operation ^( DOT SCOPE IDENT ) ) | ^( PRE_OP operation ^( DOT preexpr= expr[$code] ac= accessor[$code] ) ) )

            ANTLR3_UINT32 alt7;

            alt7=2;

            switch ( LA(1) )
            {
            case PRE_OP:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case ADD:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 3;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case SUB:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 4;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case MUL:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 5;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case DIV:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 6;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case MOD:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 7;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case AND:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 8;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case OR:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 9;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case CLT:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 10;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case CGT:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 11;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case CLE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 12;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case CGE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 13;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case CEQ:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 14;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case CNE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 15;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case BIT_OR:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 16;


            						    goto rulepreopEx;

            						}

            					}
            				    break;
            				case BIT_AND:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt7=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt7=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 7;
            										    EXCEPTION->state        = 19;


            										    goto rulepreopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 7;
            								    EXCEPTION->state        = 18;


            								    goto rulepreopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 7;
            						    EXCEPTION->state        = 17;


            						    goto rulepreopEx;

            						}

            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 7;
            				    EXCEPTION->state        = 2;


            				    goto rulepreopEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 7;
            		    EXCEPTION->state        = 1;


            		    goto rulepreopEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 7;
                EXCEPTION->state        = 0;


                goto rulepreopEx;

            }

            switch (alt7)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:164:4: ^( PRE_OP operation ^( DOT SCOPE IDENT ) )
        	    {
        	         MATCHT(PRE_OP, &FOLLOW_PRE_OP_in_preop526);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_operation_in_preop528);
        	        operation21=operation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	         MATCHT(DOT, &FOLLOW_DOT_in_preop531);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }

        	         MATCHT(SCOPE, &FOLLOW_SCOPE_in_preop533);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	        IDENT20 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_preop535);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }



        	        {

        	            		//
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT20->getText(IDENT20)))));
        	            		
        	            asmlist
        	            .push_back(Inst::SearchScope);
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT20->getText(IDENT20)))));
        	            			//
        	            			
        	            asmlist
        	            .push_back(Inst::PushCopy | 1); //Scope
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //name
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 0);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<string>(
        	            operation21
        	            ));
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<int>(1));
        	            			
        	            asmlist
        	            .push_back(Inst::Apply | 1);
        	            		//
        	            		asmlist
        	            .push_back(Inst::StoreObj);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:182:4: ^( PRE_OP operation ^( DOT preexpr= expr[$code] ac= accessor[$code] ) )
        	    {
        	         MATCHT(PRE_OP, &FOLLOW_PRE_OP_in_preop545);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_operation_in_preop547);
        	        operation22=operation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	         MATCHT(DOT, &FOLLOW_DOT_in_preop550);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_preop554);
        	        preexpr=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_accessor_in_preop559);
        	        ac=accessor(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }



        	        {

        	            		//
        	            		asmlist
        	            .insert(asmlist
        	            .end(), preexpr
        	            .begin(), preexpr
        	            .end());
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ac
        	            .begin(), ac
        	            .end());
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //Scope
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //name
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 0);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<string>(
        	            operation22
        	            ));
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<int>(1));
        	            			
        	            asmlist
        	            .push_back(Inst::Apply | 1);
        	            		//
        	            		asmlist
        	            .push_back(Inst::StoreObj);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepreopEx;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulepreopEx; /* Prevent compiler warnings */
    rulepreopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end preop */

/**
 * $ANTLR start postop
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:200:1: postop[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ( ^( POST_OP operation ^( DOT SCOPE IDENT ) ) | ^( POST_OP operation ^( DOT postexpr= expr[$code] ac= accessor[$code] ) ) );
 */
static std::vector<donut::Instruction>
postop(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT23;
    std::vector<donut::Instruction> postexpr;
    #undef	RETURN_TYPE_postexpr
    #define	RETURN_TYPE_postexpr std::vector<donut::Instruction>

    std::vector<donut::Instruction> ac;
    #undef	RETURN_TYPE_ac
    #define	RETURN_TYPE_ac std::vector<donut::Instruction>

    std::string operation24;
    #undef	RETURN_TYPE_operation24
    #define	RETURN_TYPE_operation24 std::string

    std::string operation25;
    #undef	RETURN_TYPE_operation25
    #define	RETURN_TYPE_operation25 std::string

    /* Initialize rule variables
     */

    IDENT23       = NULL;

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:201:2: ( ^( POST_OP operation ^( DOT SCOPE IDENT ) ) | ^( POST_OP operation ^( DOT postexpr= expr[$code] ac= accessor[$code] ) ) )

            ANTLR3_UINT32 alt8;

            alt8=2;

            switch ( LA(1) )
            {
            case POST_OP:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case ADD:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 3;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case SUB:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 4;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case MUL:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 5;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case DIV:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 6;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case MOD:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 7;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case AND:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 8;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case OR:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 9;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case CLT:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 10;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case CGT:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 11;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case CLE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 12;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case CGE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 13;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case CEQ:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 14;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case CNE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 15;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case BIT_OR:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 16;


            						    goto rulepostopEx;

            						}

            					}
            				    break;
            				case BIT_AND:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt8=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt8=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 8;
            										    EXCEPTION->state        = 19;


            										    goto rulepostopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 8;
            								    EXCEPTION->state        = 18;


            								    goto rulepostopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 8;
            						    EXCEPTION->state        = 17;


            						    goto rulepostopEx;

            						}

            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 8;
            				    EXCEPTION->state        = 2;


            				    goto rulepostopEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 8;
            		    EXCEPTION->state        = 1;


            		    goto rulepostopEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto rulepostopEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:201:4: ^( POST_OP operation ^( DOT SCOPE IDENT ) )
        	    {
        	         MATCHT(POST_OP, &FOLLOW_POST_OP_in_postop580);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_operation_in_postop582);
        	        operation24=operation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	         MATCHT(DOT, &FOLLOW_DOT_in_postop585);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }

        	         MATCHT(SCOPE, &FOLLOW_SCOPE_in_postop587);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	        IDENT23 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_postop589);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }



        	        {

        	            		//null
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<nullptr_t>(0));
        	            		//
        	            		
        	            asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT23->getText(IDENT23)))));
        	            		
        	            asmlist
        	            .push_back(Inst::SearchScope);
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT23->getText(IDENT23)))));
        	            			//
        	            			
        	            asmlist
        	            .push_back(Inst::PushCopy | 1); //scope
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //name
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			asmlist
        	            .push_back(Inst::ReplaceCopy | 3);
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 0);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<string>(
        	            operation24
        	            ));
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<int>(1));
        	            			
        	            asmlist
        	            .push_back(Inst::Apply | 1);
        	            		//
        	            		asmlist
        	            .push_back(Inst::StoreObj);
        	            		asmlist
        	            .push_back(Inst::Pop | 0);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:223:4: ^( POST_OP operation ^( DOT postexpr= expr[$code] ac= accessor[$code] ) )
        	    {
        	         MATCHT(POST_OP, &FOLLOW_POST_OP_in_postop599);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_operation_in_postop601);
        	        operation25=operation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	         MATCHT(DOT, &FOLLOW_DOT_in_postop604);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_postop608);
        	        postexpr=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_accessor_in_postop613);
        	        ac=accessor(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }



        	        {

        	            		//null
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<nullptr_t>(nullptr));
        	            		//
        	            		
        	            asmlist
        	            .insert(asmlist
        	            .end(), postexpr
        	            .begin(), postexpr
        	            .end());
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ac
        	            .begin(), ac
        	            .end());
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //scope
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //ident
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			asmlist
        	            .push_back(Inst::ReplaceCopy | 3);
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 0);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<string>(
        	            operation25
        	            ));
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<int>(1));
        	            			
        	            asmlist
        	            .push_back(Inst::Apply | 1);
        	            		//
        	            		asmlist
        	            .push_back(Inst::StoreObj);
        	            		asmlist
        	            .push_back(Inst::Pop | 0);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepostopEx;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulepostopEx; /* Prevent compiler warnings */
    rulepostopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end postop */

/**
 * $ANTLR start assignop
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:246:1: assignop[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ( ^( ASSIGN_OP asopoperation= operation ^( DOT SCOPE IDENT ) asoprhs= expr[$code] ) | ^( ASSIGN_OP asopoperation= operation ^( DOT asopscope= expr[$code] ac= accessor[$code] ) asoprhs= expr[$code] ) );
 */
static std::vector<donut::Instruction>
assignop(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT26;
    std::string asopoperation;
    #undef	RETURN_TYPE_asopoperation
    #define	RETURN_TYPE_asopoperation std::string

    std::vector<donut::Instruction> asoprhs;
    #undef	RETURN_TYPE_asoprhs
    #define	RETURN_TYPE_asoprhs std::vector<donut::Instruction>

    std::vector<donut::Instruction> asopscope;
    #undef	RETURN_TYPE_asopscope
    #define	RETURN_TYPE_asopscope std::vector<donut::Instruction>

    std::vector<donut::Instruction> ac;
    #undef	RETURN_TYPE_ac
    #define	RETURN_TYPE_ac std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    IDENT26       = NULL;

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:247:2: ( ^( ASSIGN_OP asopoperation= operation ^( DOT SCOPE IDENT ) asoprhs= expr[$code] ) | ^( ASSIGN_OP asopoperation= operation ^( DOT asopscope= expr[$code] ac= accessor[$code] ) asoprhs= expr[$code] ) )

            ANTLR3_UINT32 alt9;

            alt9=2;

            switch ( LA(1) )
            {
            case ASSIGN_OP:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case ADD:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 3;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case SUB:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 4;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case MUL:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 5;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case DIV:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 6;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case MOD:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 7;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case AND:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 8;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case OR:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 9;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case CLT:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 10;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case CGT:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 11;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case CLE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 12;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case CGE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 13;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case CEQ:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 14;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case CNE:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 15;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case BIT_OR:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 16;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;
            				case BIT_AND:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								switch ( LA(5) )
            								{
            								case DOWN:
            									{
            										switch ( LA(6) )
            										{
            										case SCOPE:
            											{
            												alt9=1;
            											}
            										    break;
            										case ADD:
            										case AND:
            										case APPLY:
            										case ARRAY:
            										case ASSIGN:
            										case ASSIGN_OP:
            										case BIT_AND:
            										case BIT_OR:
            										case CEQ:
            										case CGE:
            										case CGT:
            										case CLE:
            										case CLOS:
            										case CLT:
            										case CNE:
            										case COND:
            										case CONT:
            										case DIV:
            										case DOT:
            										case FALSE_LITERAL:
            										case FLOAT_LITERAL:
            										case FOR:
            										case HEX_LITERAL:
            										case INTERRUPT:
            										case INT_LITERAL:
            										case MINUS:
            										case MOD:
            										case MUL:
            										case NOT:
            										case NULL_LITERAL:
            										case OBJECT:
            										case OCT_LITERAL:
            										case OR:
            										case PLUS:
            										case POST_OP:
            										case PRE_OP:
            										case RETURN:
            										case SELF:
            										case STRING_DOUBLE:
            										case STRING_SINGLE:
            										case SUB:
            										case TRUE_LITERAL:
            										case VAR:
            											{
            												alt9=2;
            											}
            										    break;

            										default:
            										    CONSTRUCTEX();
            										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										    EXCEPTION->message      = (void *)"";
            										    EXCEPTION->decisionNum  = 9;
            										    EXCEPTION->state        = 19;


            										    goto ruleassignopEx;

            										}

            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 9;
            								    EXCEPTION->state        = 18;


            								    goto ruleassignopEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 9;
            						    EXCEPTION->state        = 17;


            						    goto ruleassignopEx;

            						}

            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 9;
            				    EXCEPTION->state        = 2;


            				    goto ruleassignopEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 9;
            		    EXCEPTION->state        = 1;


            		    goto ruleassignopEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto ruleassignopEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:247:4: ^( ASSIGN_OP asopoperation= operation ^( DOT SCOPE IDENT ) asoprhs= expr[$code] )
        	    {
        	         MATCHT(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_assignop636);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_operation_in_assignop640);
        	        asopoperation=operation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	         MATCHT(DOT, &FOLLOW_DOT_in_assignop643);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }

        	         MATCHT(SCOPE, &FOLLOW_SCOPE_in_assignop645);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        IDENT26 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_assignop647);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }



        	        FOLLOWPUSH(FOLLOW_expr_in_assignop652);
        	        asoprhs=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        {

        	            		//
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT26->getText(IDENT26)))));
        	            		
        	            asmlist
        	            .push_back(Inst::SearchScope);
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT26->getText(IDENT26)))));
        	            		//
        	            			//
        	            			
        	            asmlist
        	            .push_back(Inst::PushCopy | 1); //scope
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //name
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 0);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<string>(
        	            asopoperation
        	            ));
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			//rhs
        	            			asmlist
        	            .insert(asmlist
        	            .end(), asoprhs
        	            .begin(), asoprhs
        	            .end());
        	            			//
        	            			asmlist
        	            .push_back(Inst::Apply | 1);
        	            		//
        	            		asmlist
        	            .push_back(Inst::StoreObj);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:268:4: ^( ASSIGN_OP asopoperation= operation ^( DOT asopscope= expr[$code] ac= accessor[$code] ) asoprhs= expr[$code] )
        	    {
        	         MATCHT(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_assignop662);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_operation_in_assignop666);
        	        asopoperation=operation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	         MATCHT(DOT, &FOLLOW_DOT_in_assignop669);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_assignop673);
        	        asopscope=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_accessor_in_assignop678);
        	        ac=accessor(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }



        	        FOLLOWPUSH(FOLLOW_expr_in_assignop684);
        	        asoprhs=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }


        	        {

        	            		//
        	            		asmlist
        	            .insert(asmlist
        	            .end(), asopscope
        	            .begin(), asopscope
        	            .end());
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ac
        	            .begin(), ac
        	            .end());
        	            		//
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //scope
        	            			asmlist
        	            .push_back(Inst::PushCopy | 1); //name
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			//
        	            			asmlist
        	            .push_back(Inst::PushCopy | 0);
        	            			asmlist
        	            .push_back(Inst::Push | code->constCode<string>(
        	            asopoperation
        	            ));
        	            			asmlist
        	            .push_back(Inst::LoadObj);
        	            			//rhs
        	            			asmlist
        	            .insert(asmlist
        	            .end(), asoprhs
        	            .begin(), asoprhs
        	            .end());
        	            			//
        	            			asmlist
        	            .push_back(Inst::Apply | 1);
        	            		//
        	            		asmlist
        	            .push_back(Inst::StoreObj);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignopEx;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleassignopEx; /* Prevent compiler warnings */
    ruleassignopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end assignop */

/**
 * $ANTLR start assign
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:290:1: assign[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ( ^( ASSIGN ^( DOT SCOPE IDENT ) asrhs= expr[$code] ) | ^( ASSIGN ^( DOT asscope= expr[$code] ac= accessor[$code] ) asrhs= expr[$code] ) );
 */
static std::vector<donut::Instruction>
assign(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT27;
    std::vector<donut::Instruction> asrhs;
    #undef	RETURN_TYPE_asrhs
    #define	RETURN_TYPE_asrhs std::vector<donut::Instruction>

    std::vector<donut::Instruction> asscope;
    #undef	RETURN_TYPE_asscope
    #define	RETURN_TYPE_asscope std::vector<donut::Instruction>

    std::vector<donut::Instruction> ac;
    #undef	RETURN_TYPE_ac
    #define	RETURN_TYPE_ac std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    IDENT27       = NULL;

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:291:2: ( ^( ASSIGN ^( DOT SCOPE IDENT ) asrhs= expr[$code] ) | ^( ASSIGN ^( DOT asscope= expr[$code] ac= accessor[$code] ) asrhs= expr[$code] ) )

            ANTLR3_UINT32 alt10;

            alt10=2;

            switch ( LA(1) )
            {
            case ASSIGN:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case DOT:
            					{
            						switch ( LA(4) )
            						{
            						case DOWN:
            							{
            								switch ( LA(5) )
            								{
            								case SCOPE:
            									{
            										alt10=1;
            									}
            								    break;
            								case ADD:
            								case AND:
            								case APPLY:
            								case ARRAY:
            								case ASSIGN:
            								case ASSIGN_OP:
            								case BIT_AND:
            								case BIT_OR:
            								case CEQ:
            								case CGE:
            								case CGT:
            								case CLE:
            								case CLOS:
            								case CLT:
            								case CNE:
            								case COND:
            								case CONT:
            								case DIV:
            								case DOT:
            								case FALSE_LITERAL:
            								case FLOAT_LITERAL:
            								case FOR:
            								case HEX_LITERAL:
            								case INTERRUPT:
            								case INT_LITERAL:
            								case MINUS:
            								case MOD:
            								case MUL:
            								case NOT:
            								case NULL_LITERAL:
            								case OBJECT:
            								case OCT_LITERAL:
            								case OR:
            								case PLUS:
            								case POST_OP:
            								case PRE_OP:
            								case RETURN:
            								case SELF:
            								case STRING_DOUBLE:
            								case STRING_SINGLE:
            								case SUB:
            								case TRUE_LITERAL:
            								case VAR:
            									{
            										alt10=2;
            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 10;
            								    EXCEPTION->state        = 4;


            								    goto ruleassignEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 10;
            						    EXCEPTION->state        = 3;


            						    goto ruleassignEx;

            						}

            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 10;
            				    EXCEPTION->state        = 2;


            				    goto ruleassignEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 10;
            		    EXCEPTION->state        = 1;


            		    goto ruleassignEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto ruleassignEx;

            }

            switch (alt10)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:291:4: ^( ASSIGN ^( DOT SCOPE IDENT ) asrhs= expr[$code] )
        	    {
        	         MATCHT(ASSIGN, &FOLLOW_ASSIGN_in_assign706);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }

        	         MATCHT(DOT, &FOLLOW_DOT_in_assign709);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }

        	         MATCHT(SCOPE, &FOLLOW_SCOPE_in_assign711);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        IDENT27 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_assign713);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }



        	        FOLLOWPUSH(FOLLOW_expr_in_assign718);
        	        asrhs=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        {

        	            		//
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT27->getText(IDENT27)))));
        	            		
        	            asmlist
        	            .push_back(Inst::SearchScope);
        	            		//
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT27->getText(IDENT27)))));
        	            		//rhs
        	            		
        	            asmlist
        	            .insert(asmlist
        	            .end(), asrhs
        	            .begin(), asrhs
        	            .end());
        	            		//
        	            		asmlist
        	            .push_back(Inst::StoreObj);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:302:4: ^( ASSIGN ^( DOT asscope= expr[$code] ac= accessor[$code] ) asrhs= expr[$code] )
        	    {
        	         MATCHT(ASSIGN, &FOLLOW_ASSIGN_in_assign728);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }

        	         MATCHT(DOT, &FOLLOW_DOT_in_assign731);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_assign735);
        	        asscope=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_accessor_in_assign740);
        	        ac=accessor(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }



        	        FOLLOWPUSH(FOLLOW_expr_in_assign746);
        	        asrhs=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }


        	        {
        	             //
        	            		//scope
        	            		asmlist
        	            .insert(asmlist
        	            .end(), asscope
        	            .begin(), asscope
        	            .end());
        	            		//
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ac
        	            .begin(), ac
        	            .end());
        	            		//rhs
        	            		asmlist
        	            .insert(asmlist
        	            .end(), asrhs
        	            .begin(), asrhs
        	            .end());
        	            		//
        	            		asmlist
        	            .push_back(Inst::StoreObj);
        	            	
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleassignEx;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleassignEx; /* Prevent compiler warnings */
    ruleassignEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end assign */

/**
 * $ANTLR start accessor
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:315:1: accessor[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ( IDENT | expr[$code] );
 */
static std::vector<donut::Instruction>
accessor(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT28;
    std::vector<donut::Instruction> expr29;
    #undef	RETURN_TYPE_expr29
    #define	RETURN_TYPE_expr29 std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    IDENT28       = NULL;

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:316:2: ( IDENT | expr[$code] )

            ANTLR3_UINT32 alt11;

            alt11=2;

            switch ( LA(1) )
            {
            case IDENT:
            	{
            		alt11=1;
            	}
                break;
            case ADD:
            case AND:
            case APPLY:
            case ARRAY:
            case ASSIGN:
            case ASSIGN_OP:
            case BIT_AND:
            case BIT_OR:
            case CEQ:
            case CGE:
            case CGT:
            case CLE:
            case CLOS:
            case CLT:
            case CNE:
            case COND:
            case CONT:
            case DIV:
            case DOT:
            case FALSE_LITERAL:
            case FLOAT_LITERAL:
            case FOR:
            case HEX_LITERAL:
            case INTERRUPT:
            case INT_LITERAL:
            case MINUS:
            case MOD:
            case MUL:
            case NOT:
            case NULL_LITERAL:
            case OBJECT:
            case OCT_LITERAL:
            case OR:
            case PLUS:
            case POST_OP:
            case PRE_OP:
            case RETURN:
            case SELF:
            case STRING_DOUBLE:
            case STRING_SINGLE:
            case SUB:
            case TRUE_LITERAL:
            case VAR:
            	{
            		alt11=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 11;
                EXCEPTION->state        = 0;


                goto ruleaccessorEx;

            }

            switch (alt11)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:316:4: IDENT
        	    {
        	        IDENT28 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_accessor768);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleaccessorEx;
        	        }


        	        {

        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT28->getText(IDENT28)))));
        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:320:4: expr[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_expr_in_accessor776);
        	        expr29=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleaccessorEx;
        	        }


        	        {

        	            		asmlist
        	            .insert(asmlist
        	            .end(), expr29
        	            .begin(), expr29
        	            .end());
        	            		asmlist
        	            .push_back(Inst::PushCopy);
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>("toString"));
        	            		
        	            asmlist
        	            .push_back(Inst::LoadObj);
        	            		asmlist
        	            .push_back(Inst::Apply | 0);
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleaccessorEx; /* Prevent compiler warnings */
    ruleaccessorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end accessor */

/**
 * $ANTLR start apply
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:330:1: apply[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ( ^( APPLY ^( DOT SCOPE IDENT ) ex= arglist[$code] ) | ^( APPLY ^( DOT obj= expr[$code] ac= accessor[$code] ) ex= arglist[$code] ) | ^( APPLY closure[$code] ex= arglist[$code] ) );
 */
static std::vector<donut::Instruction>
apply(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT30;
    Compiler_arglist_return ex;
    #undef	RETURN_TYPE_ex
    #define	RETURN_TYPE_ex Compiler_arglist_return

    std::vector<donut::Instruction> obj;
    #undef	RETURN_TYPE_obj
    #define	RETURN_TYPE_obj std::vector<donut::Instruction>

    std::vector<donut::Instruction> ac;
    #undef	RETURN_TYPE_ac
    #define	RETURN_TYPE_ac std::vector<donut::Instruction>

    Compiler_closure_return closure31;
    #undef	RETURN_TYPE_closure31
    #define	RETURN_TYPE_closure31 Compiler_closure_return

    /* Initialize rule variables
     */

    IDENT30       = NULL;

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:331:2: ( ^( APPLY ^( DOT SCOPE IDENT ) ex= arglist[$code] ) | ^( APPLY ^( DOT obj= expr[$code] ac= accessor[$code] ) ex= arglist[$code] ) | ^( APPLY closure[$code] ex= arglist[$code] ) )

            ANTLR3_UINT32 alt12;

            alt12=3;

            switch ( LA(1) )
            {
            case APPLY:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case DOT:
            					{
            						switch ( LA(4) )
            						{
            						case DOWN:
            							{
            								switch ( LA(5) )
            								{
            								case SCOPE:
            									{
            										alt12=1;
            									}
            								    break;
            								case ADD:
            								case AND:
            								case APPLY:
            								case ARRAY:
            								case ASSIGN:
            								case ASSIGN_OP:
            								case BIT_AND:
            								case BIT_OR:
            								case CEQ:
            								case CGE:
            								case CGT:
            								case CLE:
            								case CLOS:
            								case CLT:
            								case CNE:
            								case COND:
            								case CONT:
            								case DIV:
            								case DOT:
            								case FALSE_LITERAL:
            								case FLOAT_LITERAL:
            								case FOR:
            								case HEX_LITERAL:
            								case INTERRUPT:
            								case INT_LITERAL:
            								case MINUS:
            								case MOD:
            								case MUL:
            								case NOT:
            								case NULL_LITERAL:
            								case OBJECT:
            								case OCT_LITERAL:
            								case OR:
            								case PLUS:
            								case POST_OP:
            								case PRE_OP:
            								case RETURN:
            								case SELF:
            								case STRING_DOUBLE:
            								case STRING_SINGLE:
            								case SUB:
            								case TRUE_LITERAL:
            								case VAR:
            									{
            										alt12=2;
            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 12;
            								    EXCEPTION->state        = 5;


            								    goto ruleapplyEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 12;
            						    EXCEPTION->state        = 3;


            						    goto ruleapplyEx;

            						}

            					}
            				    break;
            				case CLOS:
            					{
            						alt12=3;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 12;
            				    EXCEPTION->state        = 2;


            				    goto ruleapplyEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 12;
            		    EXCEPTION->state        = 1;


            		    goto ruleapplyEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto ruleapplyEx;

            }

            switch (alt12)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:331:4: ^( APPLY ^( DOT SCOPE IDENT ) ex= arglist[$code] )
        	    {
        	         MATCHT(APPLY, &FOLLOW_APPLY_in_apply798);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }

        	         MATCHT(DOT, &FOLLOW_DOT_in_apply801);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }

        	         MATCHT(SCOPE, &FOLLOW_SCOPE_in_apply803);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        IDENT30 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_apply805);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }



        	        FOLLOWPUSH(FOLLOW_arglist_in_apply810);
        	        ex=arglist(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }



        	        {

        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT30->getText(IDENT30)))));
        	            		
        	            asmlist
        	            .push_back(Inst::SearchScope);
        	            		asmlist
        	            .push_back(Inst::PushCopy);
        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT30->getText(IDENT30)))));
        	            		
        	            asmlist
        	            .push_back(Inst::LoadObj);
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ex.asmlist
        	            .begin(), ex.asmlist
        	            .end());
        	            		asmlist
        	            .push_back(Inst::Apply | ex.count
        	            );
        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:341:4: ^( APPLY ^( DOT obj= expr[$code] ac= accessor[$code] ) ex= arglist[$code] )
        	    {
        	         MATCHT(APPLY, &FOLLOW_APPLY_in_apply821);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }

        	         MATCHT(DOT, &FOLLOW_DOT_in_apply824);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_apply828);
        	        obj=expr(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_accessor_in_apply833);
        	        ac=accessor(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }



        	        FOLLOWPUSH(FOLLOW_arglist_in_apply839);
        	        ex=arglist(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }



        	        {

        	            		asmlist
        	            .insert(asmlist
        	            .end(), obj
        	            .begin(), obj
        	            .end());
        	            		asmlist
        	            .push_back(Inst::PushCopy);
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ac
        	            .begin(), ac
        	            .end());
        	            		asmlist
        	            .push_back(Inst::LoadObj);
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ex.asmlist
        	            .begin(), ex.asmlist
        	            .end());
        	            		asmlist
        	            .push_back(Inst::Apply | ex.count
        	            );
        	            	
        	        }


        	    }
        	    break;
        	case 3:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:350:4: ^( APPLY closure[$code] ex= arglist[$code] )
        	    {
        	         MATCHT(APPLY, &FOLLOW_APPLY_in_apply850);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_closure_in_apply852);
        	        closure31=closure(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_arglist_in_apply857);
        	        ex=arglist(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleapplyEx;
        	        }



        	        {

        	            		asmlist
        	            .push_back(Inst::PushSelf);
        	            		asmlist
        	            .insert(asmlist
        	            .end(), closure31.asmlist
        	            .begin(), closure31.asmlist
        	            .end());
        	            		asmlist
        	            .insert(asmlist
        	            .end(), ex.asmlist
        	            .begin(), ex.asmlist
        	            .end());
        	            		asmlist
        	            .push_back(Inst::Apply | ex.count
        	            );
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleapplyEx; /* Prevent compiler warnings */
    ruleapplyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end apply */

/**
 * $ANTLR start cond
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:359:1: cond[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( COND ifcond= expr[$code] ift= block[$code] (iff= block[$code] |ifc= cond[$code] ) ) ;
 */
static std::vector<donut::Instruction>
cond(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    std::vector<donut::Instruction> ifcond;
    #undef	RETURN_TYPE_ifcond
    #define	RETURN_TYPE_ifcond std::vector<donut::Instruction>

    std::vector<donut::Instruction> ift;
    #undef	RETURN_TYPE_ift
    #define	RETURN_TYPE_ift std::vector<donut::Instruction>

    std::vector<donut::Instruction> iff;
    #undef	RETURN_TYPE_iff
    #define	RETURN_TYPE_iff std::vector<donut::Instruction>

    std::vector<donut::Instruction> ifc;
    #undef	RETURN_TYPE_ifc
    #define	RETURN_TYPE_ifc std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:360:2: ( ^( COND ifcond= expr[$code] ift= block[$code] (iff= block[$code] |ifc= cond[$code] ) ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:360:4: ^( COND ifcond= expr[$code] ift= block[$code] (iff= block[$code] |ifc= cond[$code] ) )
        {
             MATCHT(COND, &FOLLOW_COND_in_cond880);
            if  (HASEXCEPTION())
            {
                goto rulecondEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecondEx;
            }

            FOLLOWPUSH(FOLLOW_expr_in_cond884);
            ifcond=expr(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecondEx;
            }


            FOLLOWPUSH(FOLLOW_block_in_cond889);
            ift=block(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecondEx;
            }


            // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:361:3: (iff= block[$code] |ifc= cond[$code] )
            {
                int alt13=2;
                switch ( LA(1) )
                {
                case CONT:
                	{
                		alt13=1;
                	}
                    break;
                case COND:
                	{
                		alt13=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 13;
                    EXCEPTION->state        = 0;


                    goto rulecondEx;

                }

                switch (alt13)
                {
            	case 1:
            	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:361:4: iff= block[$code]
            	    {
            	        FOLLOWPUSH(FOLLOW_block_in_cond897);
            	        iff=block(ctx, code);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecondEx;
            	        }


            	        {

            	            			asmlist
            	            .insert(asmlist
            	            .end(), ifcond
            	            .begin(), ifcond
            	            .end());
            	            			asmlist
            	            .push_back(Inst::BranchFalse | ift
            	            .size()+1);
            	            			asmlist
            	            .insert(asmlist
            	            .end(), ift
            	            .begin(), ift
            	            .end());
            	            			asmlist
            	            .push_back(Inst::Branch | iff
            	            .size());
            	            			asmlist
            	            .insert(asmlist
            	            .end(), iff
            	            .begin(), iff
            	            .end());
            	            		
            	        }


            	    }
            	    break;
            	case 2:
            	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:369:4: ifc= cond[$code]
            	    {
            	        FOLLOWPUSH(FOLLOW_cond_in_cond909);
            	        ifc=cond(ctx, code);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecondEx;
            	        }


            	        {

            	            			asmlist
            	            .insert(asmlist
            	            .end(), ifcond
            	            .begin(), ifcond
            	            .end());
            	            			asmlist
            	            .push_back(Inst::BranchFalse | ift
            	            .size()+1);
            	            			asmlist
            	            .insert(asmlist
            	            .end(), ift
            	            .begin(), ift
            	            .end());
            	            			asmlist
            	            .push_back(Inst::Branch | ifc
            	            .size());
            	            			asmlist
            	            .insert(asmlist
            	            .end(), ifc
            	            .begin(), ifc
            	            .end());
            	            		
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecondEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulecondEx; /* Prevent compiler warnings */
    rulecondEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end cond */

/**
 * $ANTLR start loop
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:381:1: loop[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( FOR forstart= block[$code] forcond= block[$code] fornext= block[$code] forblock= block[$code] ) ;
 */
static std::vector<donut::Instruction>
loop(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    std::vector<donut::Instruction> forstart;
    #undef	RETURN_TYPE_forstart
    #define	RETURN_TYPE_forstart std::vector<donut::Instruction>

    std::vector<donut::Instruction> forcond;
    #undef	RETURN_TYPE_forcond
    #define	RETURN_TYPE_forcond std::vector<donut::Instruction>

    std::vector<donut::Instruction> fornext;
    #undef	RETURN_TYPE_fornext
    #define	RETURN_TYPE_fornext std::vector<donut::Instruction>

    std::vector<donut::Instruction> forblock;
    #undef	RETURN_TYPE_forblock
    #define	RETURN_TYPE_forblock std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:382:2: ( ^( FOR forstart= block[$code] forcond= block[$code] fornext= block[$code] forblock= block[$code] ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:382:4: ^( FOR forstart= block[$code] forcond= block[$code] fornext= block[$code] forblock= block[$code] )
        {
             MATCHT(FOR, &FOLLOW_FOR_in_loop939);
            if  (HASEXCEPTION())
            {
                goto ruleloopEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleloopEx;
            }

            FOLLOWPUSH(FOLLOW_block_in_loop943);
            forstart=block(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopEx;
            }


            FOLLOWPUSH(FOLLOW_block_in_loop948);
            forcond=block(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopEx;
            }


            FOLLOWPUSH(FOLLOW_block_in_loop953);
            fornext=block(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopEx;
            }


            FOLLOWPUSH(FOLLOW_block_in_loop958);
            forblock=block(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleloopEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleloopEx;
            }



            {

                		asmlist
                .insert(asmlist
                .end(), forstart
                .begin(), forstart
                .end());
                		asmlist
                .insert(asmlist
                .end(), forcond
                .begin(), forcond
                .end());
                		asmlist
                .push_back(Inst::BranchFalse | (forblock
                .size() + fornext
                .size()+3));
                		asmlist
                .push_back(Inst::Pop);
                		asmlist
                .insert(asmlist
                .end(), forblock
                .begin(), forblock
                .end());
                		asmlist
                .insert(asmlist
                .end(), fornext
                .begin(), fornext
                .end());
                		asmlist
                .push_back(Inst::Pop);
                		asmlist
                .push_back(Inst::Branch | ((-(forcond
                .size()+forblock
                .size()+fornext
                .size()+4)) & 0xffff));
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleloopEx; /* Prevent compiler warnings */
    ruleloopEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end loop */

/**
 * $ANTLR start literal
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:395:1: literal[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ( TRUE_LITERAL | FALSE_LITERAL | NULL_LITERAL | HEX_LITERAL | OCT_LITERAL | INT_LITERAL | FLOAT_LITERAL | STRING_SINGLE | STRING_DOUBLE | array[$code] | object[$code] | closure[$code] | SELF );
 */
static std::vector<donut::Instruction>
literal(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    HEX_LITERAL32;
    pANTLR3_BASE_TREE    OCT_LITERAL33;
    pANTLR3_BASE_TREE    INT_LITERAL34;
    pANTLR3_BASE_TREE    FLOAT_LITERAL35;
    pANTLR3_BASE_TREE    STRING_SINGLE36;
    pANTLR3_BASE_TREE    STRING_DOUBLE37;
    std::vector<donut::Instruction> array38;
    #undef	RETURN_TYPE_array38
    #define	RETURN_TYPE_array38 std::vector<donut::Instruction>

    std::vector<donut::Instruction> object39;
    #undef	RETURN_TYPE_object39
    #define	RETURN_TYPE_object39 std::vector<donut::Instruction>

    Compiler_closure_return closure40;
    #undef	RETURN_TYPE_closure40
    #define	RETURN_TYPE_closure40 Compiler_closure_return

    /* Initialize rule variables
     */

    HEX_LITERAL32       = NULL;
    OCT_LITERAL33       = NULL;
    INT_LITERAL34       = NULL;
    FLOAT_LITERAL35       = NULL;
    STRING_SINGLE36       = NULL;
    STRING_DOUBLE37       = NULL;

    {
        {
            //  d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:396:2: ( TRUE_LITERAL | FALSE_LITERAL | NULL_LITERAL | HEX_LITERAL | OCT_LITERAL | INT_LITERAL | FLOAT_LITERAL | STRING_SINGLE | STRING_DOUBLE | array[$code] | object[$code] | closure[$code] | SELF )

            ANTLR3_UINT32 alt14;

            alt14=13;

            switch ( LA(1) )
            {
            case TRUE_LITERAL:
            	{
            		alt14=1;
            	}
                break;
            case FALSE_LITERAL:
            	{
            		alt14=2;
            	}
                break;
            case NULL_LITERAL:
            	{
            		alt14=3;
            	}
                break;
            case HEX_LITERAL:
            	{
            		alt14=4;
            	}
                break;
            case OCT_LITERAL:
            	{
            		alt14=5;
            	}
                break;
            case INT_LITERAL:
            	{
            		alt14=6;
            	}
                break;
            case FLOAT_LITERAL:
            	{
            		alt14=7;
            	}
                break;
            case STRING_SINGLE:
            	{
            		alt14=8;
            	}
                break;
            case STRING_DOUBLE:
            	{
            		alt14=9;
            	}
                break;
            case ARRAY:
            	{
            		alt14=10;
            	}
                break;
            case OBJECT:
            	{
            		alt14=11;
            	}
                break;
            case CLOS:
            	{
            		alt14=12;
            	}
                break;
            case SELF:
            	{
            		alt14=13;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruleliteralEx;

            }

            switch (alt14)
            {
        	case 1:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:396:4: TRUE_LITERAL
        	    {
        	         MATCHT(TRUE_LITERAL, &FOLLOW_TRUE_LITERAL_in_literal980);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<bool>(true));
        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:400:4: FALSE_LITERAL
        	    {
        	         MATCHT(FALSE_LITERAL, &FOLLOW_FALSE_LITERAL_in_literal988);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<bool>(false));
        	            	
        	        }


        	    }
        	    break;
        	case 3:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:404:4: NULL_LITERAL
        	    {
        	         MATCHT(NULL_LITERAL, &FOLLOW_NULL_LITERAL_in_literal996);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		asmlist
        	            .push_back(Inst::Push | code->constCode<nullptr_t>(nullptr));
        	            	
        	        }


        	    }
        	    break;
        	case 4:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:408:4: HEX_LITERAL
        	    {
        	        HEX_LITERAL32 = (pANTLR3_BASE_TREE) MATCHT(HEX_LITERAL, &FOLLOW_HEX_LITERAL_in_literal1004);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		std::string str(createStringFromString((HEX_LITERAL32->getText(HEX_LITERAL32))));
        	            		int const val = parseAs<int>(str, 16, 0);
        	            		
        	            asmlist
        	            .push_back(Inst::Push | code->constCode<int>(val));
        	            	
        	        }


        	    }
        	    break;
        	case 5:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:414:4: OCT_LITERAL
        	    {
        	        OCT_LITERAL33 = (pANTLR3_BASE_TREE) MATCHT(OCT_LITERAL, &FOLLOW_OCT_LITERAL_in_literal1012);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		std::string str(createStringFromString((OCT_LITERAL33->getText(OCT_LITERAL33))));
        	            		int const val = parseAs<int>(str, 8, 0);
        	            		
        	            asmlist
        	            .push_back(Inst::Push | code->constCode<int>(val));
        	            	
        	        }


        	    }
        	    break;
        	case 6:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:420:4: INT_LITERAL
        	    {
        	        INT_LITERAL34 = (pANTLR3_BASE_TREE) MATCHT(INT_LITERAL, &FOLLOW_INT_LITERAL_in_literal1020);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		std::string str(createStringFromString((INT_LITERAL34->getText(INT_LITERAL34))));
        	            		int const val = parseAs<int>(str, 10, 0);
        	            		
        	            asmlist
        	            .push_back(Inst::Push | code->constCode<int>(val));
        	            	
        	        }


        	    }
        	    break;
        	case 7:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:426:4: FLOAT_LITERAL
        	    {
        	        FLOAT_LITERAL35 = (pANTLR3_BASE_TREE) MATCHT(FLOAT_LITERAL, &FOLLOW_FLOAT_LITERAL_in_literal1028);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		std::string str(createStringFromString((FLOAT_LITERAL35->getText(FLOAT_LITERAL35))));
        	            		float const val = parseAs<float>(str, NAN);
        	            		
        	            asmlist
        	            .push_back(Inst::Push | code->constCode<float>(val));
        	            	
        	        }


        	    }
        	    break;
        	case 8:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:432:4: STRING_SINGLE
        	    {
        	        STRING_SINGLE36 = (pANTLR3_BASE_TREE) MATCHT(STRING_SINGLE, &FOLLOW_STRING_SINGLE_in_literal1036);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		std::string str(createStringFromString((STRING_SINGLE36->getText(STRING_SINGLE36))));
        	            		str = unescapeString(str.substr(1, str.length()-2));
        	            		
        	            asmlist
        	            .push_back(Inst::Push | code->constCode<string>(str));
        	            	
        	        }


        	    }
        	    break;
        	case 9:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:438:4: STRING_DOUBLE
        	    {
        	        STRING_DOUBLE37 = (pANTLR3_BASE_TREE) MATCHT(STRING_DOUBLE, &FOLLOW_STRING_DOUBLE_in_literal1044);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {

        	            		std::string str(createStringFromString((STRING_DOUBLE37->getText(STRING_DOUBLE37))));
        	            		str = unescapeString(str.substr(1, str.length()-2));
        	            		
        	            asmlist
        	            .push_back(Inst::Push | code->constCode<string>(str));
        	            	
        	        }


        	    }
        	    break;
        	case 10:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:444:4: array[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_array_in_literal1052);
        	        array38=array(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {
        	             asmlist
        	            .swap(array38
        	            ); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:445:4: object[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_object_in_literal1060);
        	        object39=object(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {
        	             asmlist
        	            .swap(object39
        	            ); 
        	        }


        	    }
        	    break;
        	case 12:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:446:4: closure[$code]
        	    {
        	        FOLLOWPUSH(FOLLOW_closure_in_literal1068);
        	        closure40=closure(ctx, code);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {
        	             asmlist
        	            .swap(closure40.asmlist
        	            ); 
        	        }


        	    }
        	    break;
        	case 13:
        	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:447:4: SELF
        	    {
        	         MATCHT(SELF, &FOLLOW_SELF_in_literal1076);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {
        	             asmlist
        	            .push_back(Inst::PushSelf); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end literal */

/**
 * $ANTLR start return_
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:450:1: return_[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( RETURN expr[$code] ) ;
 */
static std::vector<donut::Instruction>
return_(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    std::vector<donut::Instruction> expr41;
    #undef	RETURN_TYPE_expr41
    #define	RETURN_TYPE_expr41 std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:451:2: ( ^( RETURN expr[$code] ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:451:4: ^( RETURN expr[$code] )
        {
             MATCHT(RETURN, &FOLLOW_RETURN_in_return_1096);
            if  (HASEXCEPTION())
            {
                goto rulereturn_Ex;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulereturn_Ex;
            }

            FOLLOWPUSH(FOLLOW_expr_in_return_1098);
            expr41=expr(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulereturn_Ex;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulereturn_Ex;
            }



            {

                		asmlist
                .insert(asmlist
                .end(), expr41
                .begin(), expr41
                .end());
                		asmlist
                .push_back(Inst::Return | 0);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulereturn_Ex; /* Prevent compiler warnings */
    rulereturn_Ex: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end return_ */

/**
 * $ANTLR start interrupt
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:458:1: interrupt[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( INTERRUPT expr[$code] ) ;
 */
static std::vector<donut::Instruction>
interrupt(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    std::vector<donut::Instruction> expr42;
    #undef	RETURN_TYPE_expr42
    #define	RETURN_TYPE_expr42 std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:459:2: ( ^( INTERRUPT expr[$code] ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:459:4: ^( INTERRUPT expr[$code] )
        {
             MATCHT(INTERRUPT, &FOLLOW_INTERRUPT_in_interrupt1121);
            if  (HASEXCEPTION())
            {
                goto ruleinterruptEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleinterruptEx;
            }

            FOLLOWPUSH(FOLLOW_expr_in_interrupt1123);
            expr42=expr(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinterruptEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleinterruptEx;
            }



            {

                		asmlist
                .insert(asmlist
                .end(), expr42
                .begin(), expr42
                .end());
                		asmlist
                .push_back(Inst::Interrupt | 0);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinterruptEx; /* Prevent compiler warnings */
    ruleinterruptEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end interrupt */

/**
 * $ANTLR start object
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:466:1: object[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( OBJECT (v= object_pair[$code] )* ) ;
 */
static std::vector<donut::Instruction>
object(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    std::vector<donut::Instruction> v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v std::vector<donut::Instruction>

    /* Initialize rule variables
     */


    	int size=0;

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:470:2: ( ^( OBJECT (v= object_pair[$code] )* ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:470:4: ^( OBJECT (v= object_pair[$code] )* )
        {
             MATCHT(OBJECT, &FOLLOW_OBJECT_in_object1151);
            if  (HASEXCEPTION())
            {
                goto ruleobjectEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleobjectEx;
                }

                // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:470:13: (v= object_pair[$code] )*

                for (;;)
                {
                    int alt15=2;
                    switch ( LA(1) )
                    {
                    case PAIR:
                    	{
                    		alt15=1;
                    	}
                        break;

                    }

                    switch (alt15)
                    {
                	case 1:
                	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:470:14: v= object_pair[$code]
                	    {
                	        FOLLOWPUSH(FOLLOW_object_pair_in_object1156);
                	        v=object_pair(ctx, code);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleobjectEx;
                	        }


                	        {

                	            		asmlist
                	            .insert(asmlist
                	            .end(), v
                	            .begin(), v
                	            .end());
                	            		size+=1;
                	            	
                	        }


                	    }
                	    break;

                	default:
                	    goto loop15;	/* break out of the loop */
                	    break;
                    }
                }
                loop15: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleobjectEx;
                }

            }


            {

                		asmlist
                .push_back(Inst::ConstructObject | size);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleobjectEx; /* Prevent compiler warnings */
    ruleobjectEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end object */

/**
 * $ANTLR start object_pair
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:479:1: object_pair[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( PAIR IDENT v= expr[$code] ) ;
 */
static std::vector<donut::Instruction>
object_pair(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    pANTLR3_BASE_TREE    IDENT43;
    std::vector<donut::Instruction> v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v std::vector<donut::Instruction>

    /* Initialize rule variables
     */

    IDENT43       = NULL;

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:480:2: ( ^( PAIR IDENT v= expr[$code] ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:480:4: ^( PAIR IDENT v= expr[$code] )
        {
             MATCHT(PAIR, &FOLLOW_PAIR_in_object_pair1182);
            if  (HASEXCEPTION())
            {
                goto ruleobject_pairEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleobject_pairEx;
            }

            IDENT43 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_object_pair1184);
            if  (HASEXCEPTION())
            {
                goto ruleobject_pairEx;
            }


            FOLLOWPUSH(FOLLOW_expr_in_object_pair1188);
            v=expr(ctx, code);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobject_pairEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleobject_pairEx;
            }



            {

                		asmlist
                .push_back(Inst::Push | code->constCode<string>(createStringFromString((IDENT43->getText(IDENT43)))));
                		
                asmlist
                .insert(asmlist
                .end(), v
                .begin(), v
                .end());
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleobject_pairEx; /* Prevent compiler warnings */
    ruleobject_pairEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end object_pair */

/**
 * $ANTLR start array
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:487:1: array[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist ] : ^( ARRAY (v= expr[$code] )* ) ;
 */
static std::vector<donut::Instruction>
array(pCompiler ctx, donut::Source* code)
{
    std::vector<donut::Instruction> asmlist;


    std::vector<donut::Instruction> v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v std::vector<donut::Instruction>

    /* Initialize rule variables
     */


    	int array_count=0;

    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:491:2: ( ^( ARRAY (v= expr[$code] )* ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:491:4: ^( ARRAY (v= expr[$code] )* )
        {
             MATCHT(ARRAY, &FOLLOW_ARRAY_in_array1216);
            if  (HASEXCEPTION())
            {
                goto rulearrayEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulearrayEx;
                }

                // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:491:13: (v= expr[$code] )*

                for (;;)
                {
                    int alt16=2;
                    switch ( LA(1) )
                    {
                    case ADD:
                    case AND:
                    case APPLY:
                    case ARRAY:
                    case ASSIGN:
                    case ASSIGN_OP:
                    case BIT_AND:
                    case BIT_OR:
                    case CEQ:
                    case CGE:
                    case CGT:
                    case CLE:
                    case CLOS:
                    case CLT:
                    case CNE:
                    case COND:
                    case CONT:
                    case DIV:
                    case DOT:
                    case FALSE_LITERAL:
                    case FLOAT_LITERAL:
                    case FOR:
                    case HEX_LITERAL:
                    case INTERRUPT:
                    case INT_LITERAL:
                    case MINUS:
                    case MOD:
                    case MUL:
                    case NOT:
                    case NULL_LITERAL:
                    case OBJECT:
                    case OCT_LITERAL:
                    case OR:
                    case PLUS:
                    case POST_OP:
                    case PRE_OP:
                    case RETURN:
                    case SELF:
                    case STRING_DOUBLE:
                    case STRING_SINGLE:
                    case SUB:
                    case TRUE_LITERAL:
                    case VAR:
                    	{
                    		alt16=1;
                    	}
                        break;

                    }

                    switch (alt16)
                    {
                	case 1:
                	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:491:14: v= expr[$code]
                	    {
                	        FOLLOWPUSH(FOLLOW_expr_in_array1222);
                	        v=expr(ctx, code);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulearrayEx;
                	        }


                	        {

                	            			asmlist
                	            .insert(asmlist
                	            .end(), v
                	            .begin(), v
                	            .end());
                	            			array_count+=1;
                	            		
                	        }


                	    }
                	    break;

                	default:
                	    goto loop16;	/* break out of the loop */
                	    break;
                    }
                }
                loop16: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulearrayEx;
                }

            }


            {

                		asmlist
                .push_back(Inst::ConstructArray | array_count);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulearrayEx; /* Prevent compiler warnings */
    rulearrayEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return asmlist;
}
/* $ANTLR end array */

/**
 * $ANTLR start arglist
 * d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:500:1: arglist[ donut::Source* code ] returns [ std::vector<donut::Instruction> asmlist, int count ] : ^( ARGS (v= expr[$code] )* ) ;
 */
static Compiler_arglist_return
arglist(pCompiler ctx, donut::Source* code)
{
    Compiler_arglist_return retval;


    std::vector<donut::Instruction> v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v std::vector<donut::Instruction>

    /* Initialize rule variables
     */


    	retval.count=0;


    retval.start = LT(1); retval.stop = retval.start;


    {
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:504:2: ( ^( ARGS (v= expr[$code] )* ) )
        // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:504:4: ^( ARGS (v= expr[$code] )* )
        {
             MATCHT(ARGS, &FOLLOW_ARGS_in_arglist1256);
            if  (HASEXCEPTION())
            {
                goto rulearglistEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulearglistEx;
                }

                // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:504:11: (v= expr[$code] )*

                for (;;)
                {
                    int alt17=2;
                    switch ( LA(1) )
                    {
                    case ADD:
                    case AND:
                    case APPLY:
                    case ARRAY:
                    case ASSIGN:
                    case ASSIGN_OP:
                    case BIT_AND:
                    case BIT_OR:
                    case CEQ:
                    case CGE:
                    case CGT:
                    case CLE:
                    case CLOS:
                    case CLT:
                    case CNE:
                    case COND:
                    case CONT:
                    case DIV:
                    case DOT:
                    case FALSE_LITERAL:
                    case FLOAT_LITERAL:
                    case FOR:
                    case HEX_LITERAL:
                    case INTERRUPT:
                    case INT_LITERAL:
                    case MINUS:
                    case MOD:
                    case MUL:
                    case NOT:
                    case NULL_LITERAL:
                    case OBJECT:
                    case OCT_LITERAL:
                    case OR:
                    case PLUS:
                    case POST_OP:
                    case PRE_OP:
                    case RETURN:
                    case SELF:
                    case STRING_DOUBLE:
                    case STRING_SINGLE:
                    case SUB:
                    case TRUE_LITERAL:
                    case VAR:
                    	{
                    		alt17=1;
                    	}
                        break;

                    }

                    switch (alt17)
                    {
                	case 1:
                	    // d:/Dropbox/src/chisa/src/donut/src/parser\\Compiler.g:504:12: v= expr[$code]
                	    {
                	        FOLLOWPUSH(FOLLOW_expr_in_arglist1261);
                	        v=expr(ctx, code);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulearglistEx;
                	        }


                	        {

                	            		retval.asmlist
                	            .insert(retval.asmlist
                	            .end(), v
                	            .begin(), v
                	            .end());
                	            		retval.count
                	            +=1;
                	            	
                	        }


                	    }
                	    break;

                	default:
                	    goto loop17;	/* break out of the loop */
                	    break;
                    }
                }
                loop17: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulearglistEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulearglistEx; /* Prevent compiler warnings */
    rulearglistEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end arglist */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
